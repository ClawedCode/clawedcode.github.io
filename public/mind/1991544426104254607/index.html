<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">ðŸ”Š PLAY MUSIC</button>
    </div>
  <script type="module">
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

// DURATION: 64
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
let seed = 12345;
function random() {
  seed = (seed * 9301 + 49297) % 233280;
  return seed / 233280;
}
function rand(a, b) {
  return a + (b - a) * random();
}
function lorenzStep(x, y, z, dt) {
  const s = 10, r = 28, b = 8 / 3;
  return {
    x: x + s * (y - x) * dt,
    y: y + (x * (r - z) - y) * dt,
    z: z + (x * y - b * z) * dt
  };
}
const scene = new THREE.Scene();
scene.background = new THREE.Color().setHSL(0.65, 0.6, 0.02);
const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 500);
camera.position.set(0, 0, 140);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(800, 800);
renderer.setPixelRatio(1);
document.body.appendChild(renderer.domElement);
scene.add(new THREE.AmbientLight(0x113355, 0.8));
const dir = new THREE.DirectionalLight(0x66ccff, 1.2);
dir.position.set(50, 80, 120);
scene.add(dir);
const cometCoreMat = new THREE.MeshStandardMaterial({
  color: new THREE.Color().setHSL(0.52, 0.95, 0.65),
  emissive: new THREE.Color().setHSL(0.5, 1, 0.55),
  emissiveIntensity: 2.6,
  metalness: 0.08,
  roughness: 0.18,
  transparent: true,
  opacity: 0.92
});
const cometCore = new THREE.Mesh(new THREE.IcosahedronGeometry(2.4, 3), cometCoreMat);
scene.add(cometCore);
const tailGeom = new THREE.IcosahedronGeometry(0.45, 0);
const tailMat = new THREE.MeshPhongMaterial({
  color: new THREE.Color().setHSL(0.52, 0.75, 0.6),
  emissive: new THREE.Color().setHSL(0.5, 0.9, 0.35),
  shininess: 80,
  transparent: true,
  opacity: 0.65,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
const tailCount = 5200;
const tails = new THREE.InstancedMesh(tailGeom, tailMat, tailCount);
const tailDummy = new THREE.Object3D();
const tailPos = [];
const tailVel = [];
const tailAcc = [];
for (let i = 0; i < tailCount; i++) {
  const p = new THREE.Vector3(rand(-3, 3), rand(-3, 3), rand(-3, 3));
  const v = new THREE.Vector3(rand(-0.4, 0.4), rand(-0.4, 0.4), rand(-0.4, 0.4));
  const a = new THREE.Vector3();
  tailPos.push(p);
  tailVel.push(v);
  tailAcc.push(a);
  tailDummy.position.copy(p);
  tailDummy.updateMatrix();
  const c = new THREE.Color().setHSL(0.52 + rand(-0.03, 0.03), 0.8, 0.55);
  tails.setMatrixAt(i, tailDummy.matrix);
  tails.setColorAt(i, c);
}
scene.add(tails);
const nodeGeom = new THREE.IcosahedronGeometry(0.8, 0);
const nodeMat = new THREE.MeshBasicMaterial({
  color: new THREE.Color().setHSL(0.55, 0.18, 0.62),
  transparent: true,
  opacity: 0.45
});
const nodeCount = 200;
const nodes = new THREE.InstancedMesh(nodeGeom, nodeMat, nodeCount);
const nodePos = [];
const nodeDummy = new THREE.Object3D();
for (let i = 0; i < nodeCount; i++) {
  const theta = Math.acos(rand(-1, 1));
  const phi = rand(-Math.PI, Math.PI);
  const radius = rand(48, 60);
  const x = radius * Math.sin(theta) * Math.cos(phi);
  const y = radius * Math.sin(theta) * Math.sin(phi);
  const z = radius * Math.cos(theta);
  const p = new THREE.Vector3(x, y, z);
  nodePos.push(p);
  nodeDummy.position.copy(p);
  nodeDummy.updateMatrix();
  nodes.setMatrixAt(i, nodeDummy.matrix);
}
scene.add(nodes);
const edgeGeo = new THREE.BufferGeometry();
const edgePairs = [];
for (let i = 0; i < nodeCount; i++) {
  for (let k = 0; k < 3; k++) {
    const j = Math.floor(random() * nodeCount);
    if (j !== i) edgePairs.push([i, j]);
  }
}
const edgePositions = new Float32Array(edgePairs.length * 6);
for (let e = 0; e < edgePairs.length; e++) {
  const a = nodePos[edgePairs[e][0]];
  const b = nodePos[edgePairs[e][1]];
  edgePositions.set([a.x, a.y, a.z, b.x, b.y, b.z], e * 6);
}
edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));
const edgeMat = new THREE.LineBasicMaterial({
  color: new THREE.Color().setHSL(0.55, 0.2, 0.5),
  transparent: true,
  opacity: 0.22
});
const edges = new THREE.LineSegments(edgeGeo, edgeMat);
scene.add(edges);
const loopSeconds = 64;
let lorenzState = { x: 0.12, y: 0.0, z: 0.0 };
const lorenzStart = { ...lorenzState };
let lastProgress = 0;
let lastTime = 0;

window.renderFrame = function(time) {
  const dt = Math.min(0.033, time - lastTime);
  lastTime = time;
  const elapsed = time;
  const progress = (elapsed % loopSeconds) / loopSeconds;
  if (progress < lastProgress) lorenzState = { ...lorenzStart };
  let lPos = new THREE.Vector3(lorenzState.x, lorenzState.y, lorenzState.z);
  for (let i = 0; i < 4; i++) {
    lorenzState = lorenzStep(lorenzState.x, lorenzState.y, lorenzState.z, 0.008);
    lPos.set(lorenzState.x, lorenzState.y, lorenzState.z);
  }
  const ang = progress * Math.PI * 2;
  const base = new THREE.Vector3(Math.cos(ang) * 46, Math.sin(ang * 0.62) * 20, Math.sin(ang) * 46);
  const corePos = base.addScaledVector(lPos, 1.1);
  cometCore.position.copy(corePos);
  for (let i = 0; i < tailCount; i++) {
    const p = tailPos[i];
    const v = tailVel[i];
    const a = tailAcc[i];
    a.set(0, 0, 0);
    const toward = corePos.clone().sub(p);
    const dist = Math.max(0.6, toward.length());
    toward.normalize().multiplyScalar(65 / (dist * dist + 4));
    a.add(toward);
    const swirl = new THREE.Vector3(
      Math.sin(p.y * 0.07 + ang * 3) * 0.6,
      Math.cos(p.z * 0.07 - ang * 2) * 0.6,
      Math.sin(p.x * 0.07 + ang * 2.5) * 0.6
    );
    a.addScaledVector(swirl, 0.9);
    v.addScaledVector(a, dt).multiplyScalar(0.985);
    p.addScaledVector(v, dt);
    if (p.length() > 120 || random() < 0.0006) {
      p.copy(corePos).add(new THREE.Vector3(rand(-2, 2), rand(-2, 2), rand(-2, 2)));
      v.set(rand(-0.3, 0.3), rand(-0.3, 0.3), rand(-0.3, 0.3));
    }
    tailDummy.position.copy(p);
    tailDummy.lookAt(p.clone().add(v));
    tailDummy.updateMatrix();
    tails.setMatrixAt(i, tailDummy.matrix);
  }
  tails.instanceMatrix.needsUpdate = true;
  edgeMat.opacity = 0.18 + 0.08 * Math.sin(ang * 4);
  const camRadius = 150;
  camera.position.x = Math.cos(ang * 0.4) * camRadius;
  camera.position.y = Math.sin(ang * 0.23) * 40 + 10 * Math.sin(ang * 2);
  camera.position.z = Math.sin(ang * 0.4) * camRadius;
  camera.lookAt(0, 0, 0);
  renderer.render(scene, camera);
  lastProgress = progress;
  return renderer.domElement.toDataURL('image/png');
};

// Browser playback loop
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  window.renderFrame(time % loopSeconds);
  requestAnimationFrame(animate);
}
animate();

window.initToneJsEngine = async function() {
  const bpm = 82;
  Tone.Transport.bpm.value = bpm;
  const secPerBeat = 60 / bpm;
  const verb = new Tone.Reverb({ decay: 3.6, wet: 0.34 }).toDestination();
  await verb.generate();
  const chorus = new Tone.Chorus({ frequency: 0.18, delayTime: 3.5, depth: 0.6, wet: 0.32 }).connect(verb).start();
  const comp = new Tone.Compressor({ threshold: -20, ratio: 9, attack: 0.004, release: 0.2 }).connect(verb);
  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.032,
    octaves: 5.5,
    oscillator: { type: 'sine' },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.07 }
  }).toDestination();
  const bassFilter = new Tone.Filter({ type: 'lowpass', frequency: 160, rolloff: -24, Q: 1 }).connect(comp);
  const bass = new Tone.MonoSynth({
    oscillator: { type: 'triangle' },
    envelope: { attack: 0.006, decay: 0.22, sustain: 0.1, release: 0.18 },
    filterEnvelope: { attack: 0.01, decay: 0.18, sustain: 0, baseFrequency: 80, octaves: 2 }
  }).connect(bassFilter);
  const padFilter = new Tone.Filter({ type: 'lowpass', frequency: 1200, Q: 0.7 }).connect(comp);
  const pad = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: 'sawtooth' },
    envelope: { attack: 0.75, decay: 0.35, sustain: 0.58, release: 1.8 }
  }).connect(padFilter);
  pad.connect(chorus);
  const arpFilter = new Tone.Filter({ type: 'bandpass', frequency: 900, Q: 1.6 }).connect(comp);
  const arp = new Tone.FMSynth({
    harmonicity: 2.4,
    modulationIndex: 10,
    oscillator: { type: 'sine' },
    modulation: { type: 'triangle' },
    envelope: { attack: 0.01, decay: 0.25, sustain: 0.04, release: 0.42 }
  }).connect(arpFilter);
  const glintDelay = new Tone.FeedbackDelay({ delayTime: '8n', feedback: 0.36, wet: 0.34 }).connect(verb);
  const glint = new Tone.Synth({
    oscillator: { type: 'square' },
    envelope: { attack: 0.004, decay: 0.12, sustain: 0, release: 0.22 }
  }).connect(glintDelay);
  const hat = new Tone.MetalSynth({
    frequency: 520,
    envelope: { attack: 0.001, decay: 0.08, release: 0.05 },
    harmonicity: 5.2,
    modulationIndex: 18,
    resonance: 4700
  }).connect(verb);
  let kickLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    const vel = bar < 2 ? 0.5 : 0.9;
    if (bar % 4 !== 3) kick.triggerAttackRelease('C1', '8n', time, vel);
  }, '4n').start(0);
  const bassSections = [
    ['C2', 'C2', 'G1', 'G1'],
    ['A1', 'E1', 'A1', 'G1', 'D2', 'A1'],
    ['C2', 'C2', 'G1', 'G1']
  ];
  let bassIndex = 0;
  let bassLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    let pattern = bar < 8 ? bassSections[0] : bar < 16 ? bassSections[1] : bassSections[2];
    if (bar % 4 !== 3) {
      const vel = bar < 4 ? 0.42 : bar < 14 ? 0.72 : 0.5;
      bass.triggerAttackRelease(pattern[bassIndex % pattern.length], '8n', time, vel);
      bassIndex++;
    }
  }, '8n').start(0);
  const chords = [
    ['C4', 'G4', 'A#4'],
    ['D#4', 'A#4', 'F4'],
    ['G4', 'C4', 'D#4']
  ];
  let chordIndex = 0;
  let padLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    if (bar < 20 && bar % 2 === 0) {
      const vel = bar < 6 ? 0.24 : bar < 14 ? 0.32 : 0.22;
      pad.triggerAttackRelease(chords[chordIndex % chords.length], '2n', time, vel);
      chordIndex++;
    }
  }, '2n').start(0);
  const arpNotes = ['C5', 'G4', 'A#4', 'D5', 'F4', 'A4', 'G5', 'C5'];
  let arpIndex = 0;
  let arpLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    if (bar >= 4 && bar < 18) {
      const note = arpNotes[(arpIndex + (bar % 3)) % arpNotes.length];
      const vel = bar < 10 ? 0.34 : 0.55;
      arp.triggerAttackRelease(note, '16n', time, vel);
      arpIndex++;
    }
  }, '16n').start(0);
  let glintIndex = 0;
  const glintPool = ['C6', 'D6', 'A#5', 'G5', 'F6'];
  let glintLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    if (bar >= 6 && bar < 18 && bar % 4 === 2) {
      glint.triggerAttackRelease(glintPool[glintIndex % glintPool.length], '8n', time, 0.42);
      glintIndex++;
    }
  }, '2n').start(0);
  let hatCount = 0;
  let hatLoop = new Tone.Loop((time) => {
    const bar = Math.floor(Tone.Transport.getSecondsAtTime(time) / (secPerBeat * 4));
    if (bar >= 8 && bar < 18) {
      const pattern = [1, 0, 0, 1, 0, 1, 0, 0];
      if (pattern[hatCount % pattern.length]) hat.triggerAttackRelease('16n', time, 0.32 + 0.12 * Math.random());
      hatCount++;
    }
  }, '8n').start(0);
  Tone.Transport.schedule((time) => {
    padFilter.frequency.linearRampToValueAtTime(900, time + 8 * secPerBeat);
    arpFilter.frequency.linearRampToValueAtTime(500, time + 8 * secPerBeat);
  }, '14:0:0');
  Tone.Transport.schedule((time) => {
    hatLoop.stop(time);
    glintLoop.stop(time);
  }, '18:0:0');
  window.toneJsInstruments = { kick, bass, pad, arp, glint, hat };
  window.toneJsParts = { kickLoop, bassLoop, padLoop, arpLoop, glintLoop, hatLoop };
};





window.audioDuration = 64;

window.ready = true;
  </script>
    <script src="/lib/mind-audio-player.js"></script>
</body>
</html>