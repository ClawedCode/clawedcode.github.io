<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">ðŸ”Š PLAY MUSIC</button>
    </div>
  <script>
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  console.error('WebGL not supported');
  window.ready = false;
} else {
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision mediump float;
uniform vec2 iResolution;
uniform float iTime;
vec3 gRo;
vec3 gDir;
float hash(vec3 p){return fract(sin(dot(p,vec3(7.1,113.3,157.7)))*43758.5453);}
float noise(vec3 p){vec3 i=floor(p);vec3 f=fract(p);f=f*f*(3.0-2.0*f);float a=hash(vec3(i.x,i.y,i.z));float b=hash(vec3(i.x+1.0,i.y,i.z));float c=hash(vec3(i.x,i.y+1.0,i.z));float d=hash(vec3(i.x+1.0,i.y+1.0,i.z));float e=hash(vec3(i.x,i.y,i.z+1.0));float f1=hash(vec3(i.x+1.0,i.y,i.z+1.0));float g=hash(vec3(i.x,i.y+1.0,i.z+1.0));float h=hash(vec3(i.x+1.0,i.y+1.0,i.z+1.0));return mix(mix(mix(a,b,f.x),mix(c,d,f.x),f.y),mix(mix(e,f1,f.x),mix(g,h,f.x),f.y),f.z);}
float fbm(vec3 p){float v=0.0;float w=0.5;for(int i=0;i<3;i++){v+=noise(p)*w;p*=2.7;w*=0.5;}return v;}
float smin(float a,float b,float k){float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return mix(b,a,h)-k*h*(1.0-h);}
float sdBox(vec3 p,vec3 b){vec3 q=abs(p)-b;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);}
float sdCapsule(vec3 p,vec3 a,vec3 b,float r){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h)-r;}
vec3 catPath(float tt){float u=mod(tt,60.0)/60.0;float a=u*6.28318;return vec3(sin(a)*3.2,0.4*sin(a*2.1+0.4),cos(a*1.3)*3.2);}
vec3 mapScene(vec3 p){float cell=1.8;float w=fbm(p*0.3+iTime*0.12)-0.5;vec3 q=p+vec3(w*0.5,w*0.25,w*0.5);vec3 m=mod(q+cell*0.5,cell)-0.5*cell;float box=sdBox(m,vec3(0.38,0.38,0.38+0.05*sin(iTime*0.2)));float camClear=length(p-gRo);float bubble=1.0-smoothstep(2.5,6.5,camClear);vec3 d=p-gRo;float along=clamp(dot(d,gDir),0.0,28.0);vec3 closest=gRo+gDir*along;float radial=length(p-closest);float tunnelClear=1.0-smoothstep(1.6,3.4,radial);float carve=clamp(bubble+tunnelClear-bubble*tunnelClear,0.0,1.0);box=mix(4.0,box,1.0-carve);vec3 cp=p-catPath(iTime);float body=sdCapsule(cp,vec3(0.0,-0.05,-0.5),vec3(0.0,-0.05,0.7),0.28);float head=length(cp-vec3(0.0,0.28,0.62))-0.32;float ear1=sdBox(cp-vec3(0.15,0.54,0.45),vec3(0.09,0.12,0.09));float ear2=sdBox(cp-vec3(-0.15,0.54,0.45),vec3(0.09,0.12,0.09));float cat=smin(smin(smin(body,head,0.22),ear1,0.16),ear2,0.16);float scene=smin(box,cat,0.18);return vec3(scene,box,cat);}
vec3 calcNormal(vec3 p){vec2 e=vec2(0.001,0.0);return normalize(vec3(mapScene(p+e.xyy).x-mapScene(p-e.xyy).x,mapScene(p+e.yxy).x-mapScene(p-e.yxy).x,mapScene(p+e.yyx).x-mapScene(p-e.yyx).x));}
float march(vec3 ro,vec3 rd,out vec3 res){float t=0.3;float hit=0.0;for(int i=0;i<130;i++){vec3 p=ro+rd*t;vec3 d=mapScene(p);if(d.x<0.0008||t>40.0){res=p;hit=d.y-d.z;break;}t+=d.x;}return t;}
void main(){vec2 uv=(gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;float phase=mod(iTime,60.0)/60.0;vec3 target=catPath(iTime);float zoomCycle=sin(phase*3.14159)*0.5+0.5;float camDist=mix(13.0,10.5,zoomCycle);vec3 ro=vec3(0.0,1.8,camDist);vec3 f=normalize(target-ro);vec3 r=normalize(vec3(f.z,0.0,-f.x));vec3 u=normalize(cross(r,f));gRo=ro;gDir=f;vec3 rd=normalize(r*uv.x+u*uv.y+f*1.5);vec3 p;float dist=march(ro,rd,p);vec3 col=vec3(0.02,0.03,0.05);if(dist<40.0){vec3 data=mapScene(p);vec3 n=calcNormal(p);float catMask=step(data.z,data.y);vec3 light=normalize(vec3(0.4,0.8,0.2));float diff=clamp(dot(n,light),0.0,1.0);float rim=pow(1.0-max(dot(n,-rd),0.0),2.2);float cell=1.8;vec3 g=abs(fract((p+cell*0.5)/cell)-0.5);float grid=exp(-40.0*min(min(g.x,g.y),g.z));vec3 catCol=vec3(0.96,0.32,0.86);vec3 boxCol=vec3(0.16,1.1,0.52);vec3 base=mix(boxCol,catCol,catMask);float fog=exp(-0.012*dist*dist);col=base*(0.25+0.9*diff)+rim*0.55+grid*vec3(0.1,0.8,0.3);col=mix(vec3(0.01,0.02,0.03),col,fog);}gl_FragColor=vec4(pow(col,vec3(0.85)),1.0);}
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader);
      console.error('Shader compile error:', log);
      document.body.innerHTML = '<pre style="color:red;font-size:12px;padding:20px;">' + log + '</pre>';
      gl.deleteShader(shader);
      window.ready = false;
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    window.ready = false;
  } else {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');

    window.renderFrame = function(time) {
      gl.viewport(0, 0, 800, 800);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, 800, 800);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      return canvas.toDataURL('image/png');
    };

    window.ready = true;
  }
}

window.initToneJsEngine = async function() {
  const bpm = 88;
  Tone.Transport.bpm.value = bpm;
  const masterGain = new Tone.Gain(0).toDestination();
  const masterComp = new Tone.Compressor({ threshold: -18, ratio: 2, attack: 0.01, release: 0.25 }).connect(masterGain);
  const hall = new Tone.Reverb({ decay: 9, preDelay: 0.095, wet: 0.36 }).connect(masterComp);
  await hall.generate();
  const plate = new Tone.Reverb({ decay: 4.5, preDelay: 0.022, wet: 0.18 }).connect(masterComp);
  await plate.generate();
  const echo = new Tone.FeedbackDelay({ delayTime: "8n.", feedback: 0.32, wet: 0.18 }).connect(hall);
  const padBus = new Tone.Gain(0.6).connect(hall);
  const ostBus = new Tone.Gain(0).connect(echo);
  const leadBus = new Tone.Gain(0).connect(hall);
  const choirBus = new Tone.Gain(0).connect(hall);
  const brassBus = new Tone.Gain(0).connect(plate);
  const percBus = new Tone.Gain(0).connect(hall);
  const padFilter = new Tone.Filter({ type: "lowpass", frequency: 1200, Q: 0.7 }).connect(padBus);
  const padTrem = new Tone.Tremolo({ frequency: 7.5, depth: 0.25, spread: 180 }).start().connect(padFilter);
  const pad = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "sawtooth" },
    envelope: { attack: 2.4, decay: 1.4, sustain: 0.8, release: 4.2 }
  }).connect(padTrem);
  const hazePart = new Tone.Part((time, ev) => {
    pad.triggerAttackRelease(ev.chord, ev.dur, time, ev.vel);
  }, [
    { time: "0:0:0", chord: ["E4", "B4", "E5"], dur: "4m", vel: 0.35 },
    { time: "4:0:0", chord: ["D4", "A4", "D5"], dur: "4m", vel: 0.33 },
    { time: "8:0:0", chord: ["E4", "B4", "E5"], dur: "4m", vel: 0.37 },
    { time: "12:0:0", chord: ["D4", "A4", "D5"], dur: "4m", vel: 0.36 },
    { time: "16:0:0", chord: ["E4", "B4", "E5"], dur: "4m", vel: 0.34 }
  ]);
  hazePart.start(0);
  const pluck = new Tone.MonoSynth({
    oscillator: { type: "triangle" },
    filter: { type: "lowpass", frequency: 2300, Q: 10 },
    envelope: { attack: 0.002, decay: 0.19, sustain: 0.12, release: 0.08 },
    filterEnvelope: { attack: 0.001, decay: 0.12, sustain: 0.25, release: 0.1, baseFrequency: 900, octaves: 2.5 }
  }).connect(ostBus);
  let ostStep = 0;
  const ostLoop = new Tone.Loop((time) => {
    const sec = Tone.Transport.getSecondsAtTime(time);
    const bar = Math.floor(sec / ((60 / bpm) * 4));
    const chordSeq = bar < 6 ? [["E4", "B4", "E5", "G4"], ["E4", "B4", "E5", "G4"]] : bar < 12 ? [["C4", "G4", "C5", "E4"], ["D4", "A4", "D5", "F#4"]] : bar < 18 ? [["E4", "B4", "E5", "G4"], ["D4", "A4", "D5", "F#4"]] : [["E4", "B4", "E5", "G4"], ["C4", "G4", "C5", "E4"]];
    const chord = chordSeq[Math.floor(ostStep / 8) % chordSeq.length];
    const idx = ostStep % chord.length;
    const vel = bar < 2 ? 0.45 : bar < 10 ? 0.6 : bar < 15 ? 0.72 : 0.55;
    pluck.triggerAttackRelease(chord[idx], "16n", time, vel);
    ostStep++;
  }, "16n").start(0);
  const lead = new Tone.AMSynth({
    oscillator: { type: "sine" },
    modulation: { type: "triangle" },
    harmonicity: 1.02,
    envelope: { attack: 0.16, decay: 0.42, sustain: 0.78, release: 1.6 },
    modulationEnvelope: { attack: 0.03, decay: 0.2, sustain: 0.25, release: 0.7 }
  }).connect(leadBus);
  const leadVib = new Tone.Vibrato({ frequency: 5.5, depth: 0.08 }).connect(hall);
  lead.connect(leadVib);
  const leadPart = new Tone.Part((time, ev) => {
    lead.triggerAttackRelease(ev.note, ev.dur, time, ev.vel);
  }, [
    { time: "4:0:0", note: "B4", dur: "8n", vel: 0.7 },
    { time: "4:0:2", note: "C5", dur: "8n", vel: 0.72 },
    { time: "4:1:0", note: "D5", dur: "4n", vel: 0.74 },
    { time: "4:2:0", note: "E5", dur: "4n", vel: 0.76 },
    { time: "4:3:0", note: "G5", dur: "4n.", vel: 0.78 },
    { time: "5:0:2", note: "F#5", dur: "8n", vel: 0.77 },
    { time: "5:1:0", note: "E5", dur: "4n", vel: 0.76 },
    { time: "5:2:0", note: "B4", dur: "2n", vel: 0.74 },
    { time: "8:0:0", note: "D5", dur: "8n", vel: 0.78 },
    { time: "8:0:2", note: "E5", dur: "8n", vel: 0.8 },
    { time: "8:1:0", note: "G5", dur: "4n", vel: 0.82 },
    { time: "8:2:0", note: "A5", dur: "4n", vel: 0.84 },
    { time: "8:3:0", note: "B5", dur: "4n.", vel: 0.86 },
    { time: "9:0:2", note: "A5", dur: "8n", vel: 0.83 },
    { time: "9:1:0", note: "G5", dur: "4n", vel: 0.81 },
    { time: "9:2:0", note: "E5", dur: "2n", vel: 0.79 },
    { time: "12:0:0", note: "E5", dur: "8n", vel: 0.82 },
    { time: "12:0:2", note: "G5", dur: "8n", vel: 0.83 },
    { time: "12:1:0", note: "A5", dur: "4n", vel: 0.85 },
    { time: "12:2:0", note: "B5", dur: "4n", vel: 0.87 },
    { time: "12:3:0", note: "D6", dur: "4n.", vel: 0.89 },
    { time: "13:0:2", note: "C6", dur: "8n", vel: 0.88 },
    { time: "13:1:0", note: "B5", dur: "4n", vel: 0.86 },
    { time: "13:2:0", note: "G5", dur: "2n", vel: 0.84 },
    { time: "16:0:0", note: "B5", dur: "4n", vel: 0.9 },
    { time: "16:1:0", note: "D6", dur: "4n", vel: 0.91 },
    { time: "16:2:0", note: "E6", dur: "2n", vel: 0.93 },
    { time: "17:0:0", note: "D6", dur: "4n", vel: 0.9 },
    { time: "17:1:0", note: "B5", dur: "4n", vel: 0.88 },
    { time: "17:2:0", note: "G5", dur: "2n", vel: 0.85 },
    { time: "20:0:0", note: "E6", dur: "1m", vel: 0.88 },
    { time: "22:0:0", note: "D6", dur: "1m", vel: 0.86 }
  ]);
  leadPart.start(0);
  const choir = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "sine" },
    envelope: { attack: 1.3, decay: 0.7, sustain: 0.92, release: 3.6 }
  }).connect(choirBus);
  const choirPart = new Tone.Part((time, ev) => {
    choir.triggerAttackRelease(ev.chord, ev.dur, time, ev.vel);
  }, [
    { time: "6:0:0", chord: ["E4", "B4", "E5"], dur: "2m", vel: 0.36 },
    { time: "10:0:0", chord: ["D4", "A4", "D5"], dur: "2m", vel: 0.4 },
    { time: "14:0:0", chord: ["E4", "B4", "E5"], dur: "2m", vel: 0.44 },
    { time: "18:0:0", chord: ["D4", "A4", "D5"], dur: "2m", vel: 0.42 }
  ]);
  choirPart.start(0);
  const brass = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "sawtooth" },
    detune: -6,
    envelope: { attack: 0.8, decay: 0.5, sustain: 0.7, release: 3.0 }
  }).connect(brassBus);
  const brassPart = new Tone.Part((time, ev) => {
    brass.triggerAttackRelease(ev.chord, ev.dur, time, ev.vel);
  }, [
    { time: "10:2:0", chord: ["E3", "B3", "E4"], dur: "1m", vel: 0.4 },
    { time: "14:2:0", chord: ["D3", "A3", "D4"], dur: "1m", vel: 0.45 },
    { time: "18:2:0", chord: ["E3", "B3", "E4"], dur: "1m", vel: 0.42 }
  ]);
  brassPart.start(0);
  const bell = new Tone.FMSynth({
    harmonicity: 3.5,
    modulationIndex: 9,
    oscillator: { type: "sine" },
    modulation: { type: "sine" },
    envelope: { attack: 0.005, decay: 0.9, sustain: 0.25, release: 3.0 }
  }).connect(percBus);
  const bellPart = new Tone.Part((time, note) => bell.triggerAttackRelease(note, "2n", time, 0.6), [
    ["4:0:0", "E6"],
    ["8:0:0", "D6"],
    ["12:0:0", "E6"],
    ["16:0:0", "D6"],
    ["20:0:0", "E6"]
  ]);
  bellPart.start(0);
  const cym = new Tone.MetalSynth({
    frequency: 420,
    envelope: { attack: 0.003, decay: 2.2, release: 0.4 },
    harmonicity: 5.4,
    modulationIndex: 12,
    resonance: 6200,
    octaves: 2.5
  }).connect(percBus);
  const cymPart = new Tone.Part((time) => cym.triggerAttackRelease("16n", time, 0.35), ["7:3:2", "11:3:2", "15:3:2", "19:3:2"]);
  cymPart.start(0);
  const timp = new Tone.MembraneSynth({
    pitchDecay: 0.022,
    octaves: 4,
    oscillator: { type: "sine" },
    envelope: { attack: 0.006, decay: 1.8, sustain: 0, release: 0.9 }
  }).connect(percBus);
  const timpPart = new Tone.Part((time, pitch) => {
    for (let i = 0; i < 10; i++) {
      timp.triggerAttackRelease(pitch, "32n", time + i * Tone.Time("32n"), 0.45 + i * 0.035);
    }
  }, [["11:2:0", "E2"], ["15:2:0", "D2"], ["19:2:0", "E2"]]);
  timpPart.start(0);
  const droneFilter = new Tone.Filter({ type: "highpass", frequency: 180 }).connect(padBus);
  const drone = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.6, decay: 0.2, sustain: 0.0, release: 1.4 } }).connect(droneFilter);
  const dronePart = new Tone.Part((time) => drone.triggerAttackRelease(1.2, time, 0.15), [["2:2:0"], ["6:2:0"]]);
  dronePart.start(0);
  ostBus.gain.setValueAtTime(0, 0);
  ostBus.gain.linearRampToValueAtTime(0.7, Tone.now() + Tone.Time("2m"));
  leadBus.gain.setValueAtTime(0, 0);
  leadBus.gain.linearRampToValueAtTime(0.8, Tone.now() + Tone.Time("4m"));
  choirBus.gain.setValueAtTime(0, 0);
  choirBus.gain.linearRampToValueAtTime(0.55, Tone.now() + Tone.Time("8m"));
  brassBus.gain.setValueAtTime(0, 0);
  brassBus.gain.linearRampToValueAtTime(0.5, Tone.now() + Tone.Time("10m"));
  percBus.gain.setValueAtTime(0, 0);
  percBus.gain.linearRampToValueAtTime(0.6, Tone.now() + Tone.Time("12m"));
  masterGain.gain.setValueAtTime(0, 0);
  masterGain.gain.linearRampToValueAtTime(0.9, Tone.now() + Tone.Time("16m"));
  masterGain.gain.linearRampToValueAtTime(0.35, Tone.now() + Tone.Time("20m"));
  const ostFilterClose = Tone.Transport.schedule((time) => {
    pluck.filterEnvelope.baseFrequency = 700;
    pluck.filterEnvelope.octaves = 1.5;
    ostBus.gain.cancelScheduledValues(time);
    ostBus.gain.linearRampToValueAtTime(0.35, time + Tone.Time("2m"));
    leadBus.gain.linearRampToValueAtTime(0.2, time + Tone.Time("2m"));
    choirBus.gain.linearRampToValueAtTime(0.3, time + Tone.Time("2m"));
    brassBus.gain.linearRampToValueAtTime(0.1, time + Tone.Time("1m"));
    percBus.gain.linearRampToValueAtTime(0.05, time + Tone.Time("1m"));
    masterGain.gain.linearRampToValueAtTime(0.25, time + Tone.Time("2m"));
  }, "18:0:0");
  window.toneJsInstruments = { pad, pluck, lead, choir, brass, bell, cym, timp, drone };
  window.toneJsParts = { hazePart, ostLoop, leadPart, choirPart, brassPart, bellPart, cymPart, timpPart, dronePart, ostFilterClose };
};



document.body.appendChild(canvas);
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  const loopDuration = 60;
  if (window.renderFrame) {
    window.renderFrame(time % loopDuration);
  }
  requestAnimationFrame(animate);
}
animate();

window.audioDuration = 60;
  </script>
    <script src="/lib/mind-audio-player.js"></script>
</body>
</html>