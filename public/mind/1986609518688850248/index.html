<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">ðŸ”Š PLAY MUSIC</button>
    </div>
  <script>
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  console.error('WebGL not supported');
  window.ready = false;
} else {
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    // DURATION: 45
precision mediump float;
uniform vec2 iResolution;
uniform float iTime;

mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}

float sdBox(vec3 p,vec3 b){vec3 q=abs(p)-b;return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);}

float map(vec3 p){
  vec3 q=p;
  q.xz*=rot(sin(iTime*0.3)*0.4);
  q.yz*=rot(iTime*0.15);
  q=mod(q+1.5,3.0)-1.5;
  float d=sdBox(q,vec3(0.3));
  d=min(d,sdBox(q-vec3(0.0,0.8,0.0),vec3(0.15,0.05,0.15)));
  return d;
}

vec3 calcNormal(vec3 p){
  vec2 e=vec2(0.001,0.0);
  return normalize(vec3(
    map(p+e.xyy)-map(p-e.xyy),
    map(p+e.yxy)-map(p-e.yxy),
    map(p+e.yyx)-map(p-e.yyx)
  ));
}

void main(){
  vec2 uv=(gl_FragCoord.xy-0.5*iResolution.xy)/iResolution.y;

  vec3 ro=vec3(0.0,0.0,18.0);
  vec3 rd=normalize(vec3(uv,-1.5));
  rd.xz*=rot(sin(iTime*0.2)*0.3);

  float t=0.0;
  vec3 col=vec3(0.0);

  for(int i=0;i<80;i++){
    vec3 p=ro+rd*t;
    float d=map(p);
    if(d<0.001){
      vec3 n=calcNormal(p);
      float diff=max(dot(n,normalize(vec3(1.0,1.0,-1.0))),0.0);
      float rim=pow(1.0-max(dot(n,-rd),0.0),3.0);

      float fog=1.0-t*0.015;
      vec3 baseCol=vec3(0.45,0.5,0.65);
      col=baseCol*(diff*0.6+0.3)+rim*vec3(0.7,0.75,0.85)*0.8;
      col*=fog;
      break;
    }
    t+=d;
    if(t>60.0)break;
  }

  float glow=0.0;
  for(int i=0;i<5;i++){
    vec3 p=ro+rd*float(i)*2.0;
    glow+=0.008/abs(map(p));
  }
  col+=vec3(0.5,0.55,0.7)*glow*0.15;

  col=mix(vec3(0.15,0.18,0.25),col,exp(-0.001*t*t));

  gl_FragColor=vec4(col,1.0);
}
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader);
      console.error('Shader compile error:', log);
      document.body.innerHTML = '<pre style="color:red;font-size:12px;padding:20px;">' + log + '</pre>';
      gl.deleteShader(shader);
      window.ready = false;
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    window.ready = false;
  } else {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');

    window.renderFrame = function(time) {
      gl.viewport(0, 0, 800, 800);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, 800, 800);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      return canvas.toDataURL('image/png');
    };

    window.ready = true;
  }
}

// Audio code injection (Tone.js audioRecipe only)
window.audioRecipe = {
  "global": {
    "bpm": 95,
    "key": "G",
    "scale": "natural_minor"
  },
  "sections": [
    {
      "name": "intro",
      "bars": 3
    },
    {
      "name": "grooveA",
      "bars": 4
    },
    {
      "name": "grooveB",
      "bars": 4
    },
    {
      "name": "drop",
      "bars": 3
    },
    {
      "name": "outro",
      "bars": 2
    }
  ],
  "progression": [
    "i",
    "VII",
    "VI",
    "VII"
  ],
  "instruments": {
    "bass": {
      "wave": "saw",
      "voices": 2,
      "detune_cents": 12,
      "filter": {
        "type": "lowpass",
        "cutoff_hz": 160,
        "q": 0.8,
        "env_amt": 200
      },
      "amp_env": {
        "a": 0.002,
        "d": 0.09,
        "s": 0.65,
        "r": 0.14
      },
      "pattern": "8n_pulse",
      "sidechain_duck_db": 7
    },
    "arp": {
      "wave": "saw",
      "octave_range": [
        4,
        5
      ],
      "gate": 0.8,
      "delay": {
        "sync": "8n.",
        "mix": 0.35,
        "feedback": 0.4
      },
      "pattern": "updown_8n_scale"
    },
    "pad": {
      "poly": 6,
      "wave": "saw",
      "chorus": {
        "depth": 0.75,
        "rate_hz": 1.1,
        "mix": 0.55
      },
      "filter": {
        "type": "lowpass",
        "cutoff_hz": 1600,
        "q": 0.35
      },
      "env": {
        "a": 0.25,
        "d": 0.7,
        "s": 0.65,
        "r": 1.8
      },
      "hp_cut_hz": 170
    },
    "lead": {
      "mono": true,
      "wave": "square",
      "glide_s": 0.07,
      "vibrato": {
        "rate_hz": 5.5,
        "depth": 0.006
      },
      "delay": {
        "sync": "8n.",
        "mix": 0.3,
        "feedback": 0.4
      },
      "reverb": {
        "predelay_ms": 25,
        "decay_s": 1.8,
        "mix": 0.2
      }
    },
    "drums": {
      "kit": "linn",
      "kick": {
        "pattern": "4onfloor",
        "gain": -1
      },
      "snare": {
        "pattern": "2and4",
        "gated_plate": true
      },
      "hat_open": {
        "pattern": "offbeats"
      },
      "tom_fills": {
        "every_8_bars": true
      }
    }
  }
};

window.vocalLyrics = `5-6: pigeons circle overhead
8-9: sensing what we cannot see
11-12: the glitch remains
14-15: fear encoded in their flight
17-18: maybe they know
19-20: the city`;


// Tone.js Synthwave Engine
// Consumes window.audioRecipe JSON and generates dynamic synthwave audio
window.initToneJsEngine = async function() {
  if (window.toneJsInitialized) return;
  window.toneJsInitialized = true;

  // Note: Tone.start() is called by the button handler before this function
  // to ensure proper user gesture context for AudioContext

  const recipe = window.audioRecipe;
  if (!recipe) {
    console.error('No audio recipe found');
    return;
  }

  // ==== PATTERN GENERATORS ====
  // Generate rhythmic patterns based on pattern type

  /**
   * Euclidean rhythm generator (Bjorklund algorithm)
   * Distributes k beats across n steps as evenly as possible
   */
  function euclidean(steps, pulses) {
    if (pulses >= steps) return Array(steps).fill(1);
    if (pulses === 0) return Array(steps).fill(0);

    const pattern = [];
    const counts = [];
    const remainders = [];
    let divisor = steps - pulses;
    remainders.push(pulses);
    let level = 0;

    while (remainders[level] > 1) {
      counts.push(Math.floor(divisor / remainders[level]));
      remainders.push(divisor % remainders[level]);
      divisor = remainders[level];
      level++;
    }
    counts.push(divisor);

    function build(level) {
      if (level === -1) {
        pattern.push(0);
      } else if (level === -2) {
        pattern.push(1);
      } else {
        for (let i = 0; i < counts[level]; i++) {
          build(level - 1);
        }
        if (remainders[level] !== 0) {
          build(level - 2);
        }
      }
    }

    build(level);
    return pattern.slice(0, steps);
  }

  /**
   * Generate pattern based on type
   * @param {string} type - Pattern type (16n_groove, updown_8n, random_16n, etc.)
   * @param {number} steps - Number of steps in pattern
   * @returns {Array<number>} - Array of note indices (0-based, -1 = rest)
   */
  function generatePattern(type, steps = 8) {
    switch(type) {
      case '16n_groove':
      case '8n_groove':
        // Syncopated groove: play on beats 1, 3.5, 5, 7
        return Array(steps).fill(null).map((_, i) =>
          [0, 3, 4, 6].includes(i) ? 0 : -1
        );

      case 'updown_8n':
      case 'updown_16n':
        // Up-down arpeggio through triad: 0, 1, 2, 1, repeat
        return [0, 1, 2, 1, 0, 1, 2, 1];

      case 'random_8n':
      case 'random_16n':
        // Random notes from triad
        return Array(steps).fill(null).map(() =>
          Math.random() > 0.3 ? Math.floor(Math.random() * 3) : -1
        );

      case 'euclidean_8_5':
        // 5 beats distributed across 8 steps
        const e85 = euclidean(8, 5);
        return e85.map((hit, i) => hit ? i % 3 : -1);

      case 'euclidean_16_9':
        // 9 beats distributed across 16 steps
        const e169 = euclidean(16, 9);
        return e169.map((hit, i) => hit ? i % 3 : -1);

      default:
        // Simple triad pattern
        return [0, 1, 2, 1, 0, 1, 2, 1];
    }
  }

  /**
   * Apply velocity array to pattern
   * @param {Array} pattern - Pattern of note indices
   * @param {Array} velocities - Velocity for each step (0.0-1.5)
   * @returns {Array} - Pattern with velocities applied (null for rests)
   */
  function applyVelocities(pattern, velocities) {
    return pattern.map((noteIdx, step) => {
      const vel = velocities[step % velocities.length];
      if (noteIdx === -1 || vel === 0) return null;
      return { noteIdx, velocity: vel };
    });
  }

  // ---- Global Setup ----
  const BPM = recipe.global.bpm || 86;
  Tone.Transport.bpm.value = BPM;

  // Scale helper
  const Scale = {
    natural_minor: [0, 2, 3, 5, 7, 8, 10],
    notes(key = "F") {
      const semis = {"C":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"F":5,"F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11};
      return (degree) => (semis[key] + degree) % 12;
    }
  };

  const key = recipe.global.key || "F";
  const scale = recipe.global.scale || "natural_minor";
  const noteNum = Scale.notes(key);

  // Map Roman numerals to scale degrees in natural minor
  const romanToDegree = {
    "i": 0, "ii": 2, "III": 3, "iv": 5, "v": 7, "VI": 8, "VII": 10,
    "bIII": 3, "bVI": 8, "bVII": 10, "IV": 5, "V": 7  // Add flat and major variants
  };

  const progression = recipe.progression || ["i","VI","III","VII"];
  const chordRootMIDIs = progression.map(rn => 53 + romanToDegree[rn]);

  function buildTriad(rootMidi) {
    return [rootMidi, rootMidi+3, rootMidi+7];
  }

  // ---- Buses / FX ----
  const mixBus = new Tone.Gain(1).toDestination();

  const verb = new Tone.Reverb({
    decay: recipe.instruments?.lead?.reverb?.decay_s || 1.6,
    preDelay: 0.02,
    wet: 0.08
  }).connect(mixBus);
  await verb.generate();

  const chorus = new Tone.Chorus({
    frequency: recipe.instruments?.pad?.chorus?.rate_hz || 1.2,
    depth: recipe.instruments?.pad?.chorus?.depth || 0.7,
    wet: 0.4
  }).start().connect(mixBus);

  const delayDotted8 = new Tone.FeedbackDelay("8n.", 0.35);
  delayDotted8.wet.value = 0.25;
  delayDotted8.connect(mixBus);

  // Duck bus for sidechain (pads/bass feed this)
  const duckBus = new Tone.Gain(1).connect(mixBus);

  // ---- Instruments ----
  // Map short wave names to Tone.js types
  const waveMap = { "saw": "sawtooth", "sawtooth": "sawtooth", "square": "square", "sine": "sine", "triangle": "triangle" };

  const bassConfig = recipe.instruments?.bass || {};
  const bass = new Tone.MonoSynth({
    oscillator: { type: waveMap[bassConfig.wave] || "sawtooth" },
    filter: {
      type: "lowpass",
      Q: bassConfig.filter?.q || 0.7,
      frequency: bassConfig.filter?.cutoff_hz || 180
    },
    envelope: {
      attack: 0.002,
      decay: 0.08,
      sustain: 0.7,
      release: 0.12
    },
    filterEnvelope: {
      attack: 0.002,
      decay: 0.06,
      sustain: 0.0,
      release: 0.1,
      baseFrequency: 120,
      octaves: 1.2
    }
  }).connect(duckBus);

  const subBassConfig = recipe.instruments?.sub_bass || {};
  const subBass = new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: {
      attack: 0.005,
      decay: 0.2,
      sustain: 0.9,
      release: 0.3
    }
  }).connect(duckBus);

  const arpConfig = recipe.instruments?.arp || {};
  const arp = new Tone.Synth({
    oscillator: { type: waveMap[arpConfig.wave] || "sawtooth" },
    envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.15 }
  }).connect(delayDotted8);

  const padConfig = recipe.instruments?.pad || {};
  const pad = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: waveMap[padConfig.wave] || "sawtooth" },
    envelope: {
      attack: 0.2,
      decay: 0.6,
      sustain: 0.7,
      release: 1.5
    }
  });
  const padFilter = new Tone.Filter(padConfig.hp_cut_hz || 180, "highpass");
  pad.connect(padFilter);
  padFilter.connect(chorus);
  chorus.connect(duckBus);
  duckBus.connect(mixBus); // Bass/pads go directly to mix, no reverb

  const leadConfig = recipe.instruments?.lead || {};
  const lead = new Tone.MonoSynth({
    oscillator: { type: waveMap[leadConfig.wave] || "square" },
    portamento: leadConfig.glide_s || 0.06,
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.6, release: 0.3 }
  });
  lead.connect(delayDotted8);
  delayDotted8.connect(verb); // Only lead gets reverb

  // ---- Drums ----
  const drumConfig = recipe.instruments?.drums || {};
  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.03,
    octaves: 6,
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.2 }
  }).connect(mixBus);

  const snareNoise = new Tone.NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
  });
  const snareTone = new Tone.MetalSynth({
    frequency: 200,
    envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000
  }).connect(mixBus);
  const snareVerb = new Tone.Reverb({ decay: 1.0, preDelay: 0.01, wet: 0.2 });
  snareNoise.connect(snareVerb);
  snareVerb.connect(mixBus);

  const hat = new Tone.MetalSynth({
    frequency: 250,
    envelope: { attack: 0.001, decay: 0.05, release: 0.005 },
    harmonicity: 5,
    modulationIndex: 10,
    resonance: 4000
  }).connect(mixBus);

  // ---- Sidechain ducking ----
  function duck(time) {
    // Skip ducking entirely - sidechain causes timing issues in browser playback
    // This effect is primarily for video rendering and can be safely disabled for HTML playback
    return;
  }

  // ---- Sequencing ----
  function chordAtBar(barIdx) {
    const chordRoot = chordRootMIDIs[barIdx % chordRootMIDIs.length];
    return buildTriad(chordRoot);
  }

  // Calculate total duration from sections
  const totalBars = recipe.sections.reduce((sum, s) => sum + s.bars, 0);

  // Build section timing map: { sectionName: { startBar, endBar } }
  const sectionTiming = {};
  let currentBar = 0;
  recipe.sections.forEach(section => {
    const sectionName = section.name || `section_${currentBar}`;
    sectionTiming[sectionName] = {
      startBar: currentBar,
      endBar: currentBar + section.bars
    };
    currentBar += section.bars;
  });

  // Helper: Get current section name based on bar number
  function getCurrentSection(bar) {
    for (const [name, timing] of Object.entries(sectionTiming)) {
      if (bar >= timing.startBar && bar < timing.endBar) {
        return name;
      }
    }
    return null;
  }

  // Helper: Check if instrument is enabled in current section
  function isInstrumentEnabled(instrumentConfig, currentSection) {
    if (!currentSection) return true; // Default enabled if no section match
    const overrides = instrumentConfig.section_overrides || {};
    const sectionOverride = overrides[currentSection];

    // If section override exists and has enabled field, use it
    if (sectionOverride && typeof sectionOverride.enabled === 'boolean') {
      return sectionOverride.enabled;
    }

    // Default to enabled if no override specified
    return true;
  }

  // Helper: Check if drum part is enabled in current section
  function isDrumPartEnabled(drumPartConfig, currentSection) {
    if (!currentSection) return true;
    const overrides = drumPartConfig.section_overrides || {};
    const sectionOverride = overrides[currentSection];

    if (sectionOverride && typeof sectionOverride.enabled === 'boolean') {
      return sectionOverride.enabled;
    }

    return true;
  }

  // ==== BASS SEQUENCER ====
  let bassPart;
  if (bassConfig.melody) {
    // Melody mode: absolute MIDI notes
    const melody = bassConfig.melody;
    const rhythm = bassConfig.rhythm || "8n";
    const velocities = bassConfig.velocity || melody.map(() => 0.65);
    const startBeat = bassConfig.startBeat || 0;
    const stopBeat = bassConfig.stopBeat || Infinity;

    let stepIndex = 0;
    bassPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(bassConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          bass.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    // Pattern mode: chord-relative patterns
    const bassPattern = generatePattern(bassConfig.pattern || '16n_groove', 8);
    const bassVelocities = bassConfig.velocity || [0.65, 0.7, 0.62, 0.68, 0.66, 0.72, 0.64, 0.69];
    const bassPatternWithVel = applyVelocities(bassPattern, bassVelocities);

    bassPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar);
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = bassPatternWithVel[stepInBar % bassPatternWithVel.length];

      if (step && isInstrumentEnabled(bassConfig, currentSection)) {
        const note = triad[step.noteIdx]; // Play from triad
        bass.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  // ==== SUB BASS SEQUENCER ====
  const subBassVelocities = subBassConfig.velocity || [0.7, 0.7, 0.7, 0.7];
  const subBassPattern = [0, -1, -1, -1]; // Root note on quarter notes
  const subBassPatternWithVel = applyVelocities(subBassPattern, subBassVelocities);

  const subBassPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);
    const triad = chordAtBar(bar).map(n => n - 12); // Octave down
    const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("4n").toTicks());
    const step = subBassPatternWithVel[stepInBar % subBassPatternWithVel.length];

    if (step && isInstrumentEnabled(subBassConfig, currentSection)) {
      const note = triad[0]; // Always root note
      subBass.triggerAttackRelease(Tone.Frequency(note, "midi"), "4n", time, step.velocity);
    }
  }, "4n").start(0);

  // ==== ARP SEQUENCER ====
  let arpPart;
  if (arpConfig.melody) {
    // Melody mode: absolute MIDI notes
    const melody = arpConfig.melody;
    const rhythm = arpConfig.rhythm || "8n";
    const velocities = arpConfig.velocity || melody.map(() => 0.5);
    const startBeat = arpConfig.startBeat || 0;
    const stopBeat = arpConfig.stopBeat || Infinity;

    let stepIndex = 0;
    arpPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(arpConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          arp.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    // Pattern mode: chord-relative patterns
    const arpPattern = generatePattern(arpConfig.pattern || 'updown_8n', 8);
    const arpVelocities = arpConfig.velocity || [0.48, 0.52, 0.45, 0.5, 0.47, 0.53, 0.46, 0.51];
    const arpPatternWithVel = applyVelocities(arpPattern, arpVelocities);

    arpPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar).map(n => n + 12); // Octave up
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = arpPatternWithVel[stepInBar % arpPatternWithVel.length];

      if (step && isInstrumentEnabled(arpConfig, currentSection)) {
        const note = triad[step.noteIdx];
        arp.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  // ==== PAD SEQUENCER ====
  // Pads sustain full chords for the bar duration
  const padPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);
    const triad = chordAtBar(bar).map(n => n - 12); // Octave down
    const velocity = (padConfig.velocity && padConfig.velocity[0]) || 0.45;

    if (isInstrumentEnabled(padConfig, currentSection)) {
      pad.triggerAttackRelease(triad.map(n => Tone.Frequency(n, "midi")), "1m", time, velocity);
    }
  }, "1m").start(0);

  // Drums
  const kickConfig = drumConfig.kick || {};
  const kickPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(kickConfig, currentSection)) {
      kick.triggerAttackRelease("C1", "8n", time);
      duck(time);
    }
  }, "4n").start(0);

  const snareConfig = drumConfig.snare || {};
  const snarePart = new Tone.Part((time) => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(snareConfig, currentSection)) {
      snareNoise.triggerAttackRelease("8n", time);
      snareTone.triggerAttackRelease("16n", time);
    }
  }, [
    ["0:2:0", null],
    ["0:3:2", null]
  ]).start(0);
  snarePart.loop = true;
  snarePart.loopEnd = "1m";

  const hatClosedConfig = drumConfig.hat_closed || {};
  const hatPart = new Tone.Part((time) => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(hatClosedConfig, currentSection)) {
      hat.triggerAttackRelease("32n", time);
    }
  }, [["0:0:2"], ["0:1:2"], ["0:2:2"], ["0:3:2"]]).start(0);
  hatPart.loop = true;
  hatPart.loopEnd = "1m";

  // ==== LEAD SEQUENCER ====
  let leadPart;
  if (leadConfig.melody) {
    // Melody mode: absolute MIDI notes
    const melody = leadConfig.melody;
    const rhythm = leadConfig.rhythm || "8n";
    const velocities = leadConfig.velocity || melody.map(() => 0.75);
    const startBeat = leadConfig.startBeat || 0;
    const stopBeat = leadConfig.stopBeat || Infinity;

    let stepIndex = 0;
    leadPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(leadConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          lead.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    // Pattern mode: chord-relative patterns
    const leadPattern = generatePattern(leadConfig.pattern || 'updown_8n', 8);
    const leadVelocities = leadConfig.velocity || [0.75, 0.82, 0.78, 0.8];
    const leadPatternWithVel = applyVelocities(leadPattern, leadVelocities);

    leadPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar).map(n => n + 12); // Octave up
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = leadPatternWithVel[stepInBar % leadPatternWithVel.length];

      if (step && isInstrumentEnabled(leadConfig, currentSection)) {
        const note = triad[step.noteIdx];
        lead.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  // NOTE: Vocals are handled via TTS + vocoder processing (not Tone.js synth)
  // See vocal-synthesis-service.js for TTS vocal generation

  // Store parts and instruments for external control
  window.toneJsParts = { bassPart, subBassPart, arpPart, padPart, leadPart, kickPart, snarePart, hatPart };
  window.toneJsInstruments = { bass, subBass, arp, pad, lead, kick, snareNoise, snareTone, hat };
  window.toneJsFx = { verb, chorus, delayDotted8 };

  // Store cleanup function
  window.cleanupAudio = function() {
    Tone.Transport.stop();
    Tone.Transport.cancel();
    bassPart.dispose();
    subBassPart.dispose();
    arpPart.dispose();
    padPart.dispose();
    leadPart.dispose();
    kickPart.dispose();
    snarePart.dispose();
    hatPart.dispose();
    bass.dispose();
    subBass.dispose();
    arp.dispose();
    pad.dispose();
    lead.dispose();
    kick.dispose();
    snareNoise.dispose();
    snareTone.dispose();
    hat.dispose();
    verb.dispose();
    chorus.dispose();
    delayDotted8.dispose();
    window.toneJsInitialized = false;
  };
};


document.body.appendChild(canvas);
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  const loopDuration = 45;
  if (window.renderFrame) {
    window.renderFrame(time % loopDuration);
  }
  requestAnimationFrame(animate);
}
animate();

// Expose duration for shared audio player
window.audioDuration = 45;
  </script>
    <script src="/lib/mind-audio-player.js"></script>
</body>
</html>