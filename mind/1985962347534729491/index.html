<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">ðŸ”Š PLAY MUSIC</button>
    </div>
  <script>
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  console.error('WebGL not supported');
  window.ready = false;
} else {
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision mediump float;
uniform vec2 iResolution;
uniform float iTime;

mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}

float sdSphere(vec3 p,float r){return length(p)-r;}

float sdOctahedron(vec3 p,float s){
  p=abs(p);
  return(p.x+p.y+p.z-s)*0.57735027;
}

float smin(float a,float b,float k){
  float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);
  return mix(b,a,h)-k*h*(1.0-h);
}

float map(vec3 p){
  vec3 q=p;
  
  float freq=0.18+0.02*sin(iTime*0.3);
  float t=iTime*0.25;
  
  q.xz*=rot(sin(t)*0.3);
  q.yz*=rot(cos(t*0.7)*0.2);
  
  float d1=sdSphere(q,0.8);
  
  vec3 r=q;
  r*=3.0+0.5*sin(t*0.6);
  r=mod(r+1.5,3.0)-1.5;
  float d2=sdOctahedron(r,0.35);
  
  float fold=smin(d1,d2,0.4);
  
  vec3 s=q;
  for(int i=0;i<3;i++){
    s=abs(s)-vec3(0.3,0.4,0.3);
    s.xy*=rot(freq*6.28318);
  }
  float d3=sdSphere(s,0.15);
  
  return smin(fold,d3,0.3);
}

vec3 calcNormal(vec3 p){
  vec2 e=vec2(0.001,0.0);
  return normalize(vec3(
    map(p+e.xyy)-map(p-e.xyy),
    map(p+e.yxy)-map(p-e.yxy),
    map(p+e.yyx)-map(p-e.yyx)
  ));
}

void main(){
  vec2 uv=(gl_FragCoord.xy*2.0-iResolution.xy)/iResolution.y;
  
  vec3 ro=vec3(0.0,0.0,3.5);
  vec3 rd=normalize(vec3(uv,-1.8));

  float t=0.2;
  vec3 col=vec3(0.0);
  
  for(int i=0;i<80;i++){
    vec3 p=ro+rd*t;
    float d=map(p);
    if(d<0.001||t>20.0)break;
    t+=d;
  }
  
  if(t<20.0){
    vec3 p=ro+rd*t;
    vec3 n=calcNormal(p);
    vec3 ld=normalize(vec3(1.0,1.0,0.5));
    
    float diff=max(dot(n,ld),0.0);
    float rim=pow(1.0-max(dot(n,-rd),0.0),3.0);
    float ao=1.0-float(t)/20.0;
    
    float phase=iTime*0.15;
    vec3 c1=vec3(0.45,0.25,0.65);
    vec3 c2=vec3(0.25,0.45,0.70);
    vec3 baseCol=mix(c1,c2,0.5+0.5*sin(length(p)*2.0-phase*2.0));
    
    col=baseCol*(diff*0.7+0.3)*ao;
    col+=rim*vec3(0.5,0.6,0.8)*0.4;
  }else{
    col=vec3(0.02,0.02,0.03);
  }
  
  gl_FragColor=vec4(col,1.0);
}
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader);
      console.error('Shader compile error:', log);
      document.body.innerHTML = '<pre style="color:red;font-size:12px;padding:20px;">' + log + '</pre>';
      gl.deleteShader(shader);
      window.ready = false;
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    window.ready = false;
  } else {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');

    window.renderFrame = function(time) {
      gl.viewport(0, 0, 800, 800);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, 800, 800);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      return canvas.toDataURL('image/png');
    };

    window.ready = true;
  }
}

window.audioRecipe = {
  "global": {
    "bpm": 91,
    "key": "A",
    "scale": "natural_minor",
    "swing": 0.16
  },
  "sections": [
    {
      "name": "intro",
      "bars": 4
    },
    {
      "name": "grooveA",
      "bars": 5
    },
    {
      "name": "grooveB",
      "bars": 5
    },
    {
      "name": "drop",
      "bars": 4
    },
    {
      "name": "outro",
      "bars": 2
    }
  ],
  "progression": [
    "i",
    "bVII",
    "VI",
    "V"
  ],
  "instruments": {
    "bass": {
      "wave": "saw",
      "voices": 2,
      "detune_cents": 12,
      "filter": {
        "type": "lowpass",
        "cutoff_hz": 165,
        "q": 0.8,
        "env_amt": 190
      },
      "amp_env": {
        "a": 0.002,
        "d": 0.09,
        "s": 0.65,
        "r": 0.14
      },
      "pattern": "16n_groove",
      "velocity": [
        0.5,
        0.223,
        0.422,
        0.246,
        0.517,
        0.44,
        0.528,
        0.234
      ],
      "sidechain_duck_db": 6,
      "section_overrides": {
        "intro": {
          "enabled": false
        },
        "grooveA": {
          "enabled": true,
          "velocity": [
            0.5,
            0.5
          ]
        },
        "outro": {
          "pattern": "minimal",
          "velocity": [
            0.5,
            0.5
          ]
        }
      },
      "baseVolume": 0.7
    },
    "arp": {
      "wave": "triangle",
      "octave_range": [
        3,
        4
      ],
      "gate": 0.42,
      "delay": {
        "sync": "8n.",
        "mix": 0.38,
        "feedback": 0.32
      },
      "pattern": "random_8n",
      "velocity": [
        0.12
      ],
      "section_overrides": {
        "intro": {
          "enabled": false
        },
        "grooveA": {
          "enabled": true,
          "velocity": [
            0.12,
            0.11,
            0.13
          ]
        },
        "outro": {
          "enabled": false
        }
      },
      "patternData": [
        1,
        1,
        1,
        -1,
        -1,
        0,
        1,
        -1
      ],
      "baseVolume": 0.3
    },
    "pad": {
      "poly": 6,
      "wave": "saw",
      "chorus": {
        "depth": 0.58,
        "rate_hz": 1.25,
        "mix": 0.52
      },
      "filter": {
        "type": "lowpass",
        "cutoff_hz": 1520,
        "q": 0.4
      },
      "env": {
        "a": 0.28,
        "d": 0.65,
        "s": 0.68,
        "r": 1.6
      },
      "hp_cut_hz": 185,
      "section_overrides": {
        "intro": {
          "enabled": true
        }
      },
      "velocity": [
        0.04
      ],
      "baseVolume": 0.04
    },
    "lead": {
      "mono": true,
      "wave": "square",
      "glide_s": 0.07,
      "vibrato": {
        "rate_hz": 5.2,
        "depth": 0.005
      },
      "delay": {
        "sync": "8n.",
        "mix": 0.28,
        "feedback": 0.38
      },
      "reverb": {
        "predelay_ms": 22,
        "decay_s": 1.7,
        "mix": 0.19
      },
      "melody": [
        69,
        69,
        71,
        72,
        69,
        0,
        67,
        69
      ],
      "rhythm": "4n",
      "velocity": [
        0.3,
        0.3,
        0.3,
        0.3,
        0.3,
        0,
        0.3,
        0.3
      ],
      "startBeat": 16,
      "stopBeat": 64,
      "section_overrides": {
        "intro": {
          "enabled": false
        },
        "grooveA": {
          "enabled": false
        },
        "grooveB": {
          "enabled": false
        },
        "drop": {
          "enabled": false
        },
        "outro": {
          "enabled": false
        }
      },
      "baseVolume": 0.7
    },
    "drums": {
      "kit": "linn",
      "kick": {
        "pattern": "4onfloor_ghost",
        "gain": -1,
        "velocity": [
          0.23,
          0.07,
          0.22,
          0.06,
          0.24,
          0.075,
          0.22,
          0.06
        ],
        "section_overrides": {
          "intro": {
            "enabled": false
          },
          "grooveA": {
            "enabled": true,
            "pattern": "4onfloor",
            "velocity": [
              0.23,
              0.23
            ]
          }
        },
        "baseVolume": 0.9
      },
      "snare": {
        "pattern": "roll_4beat",
        "gated_plate": true,
        "velocity": [
          0.73,
          0.768
        ],
        "section_overrides": {
          "intro": {
            "enabled": false
          },
          "grooveA": {
            "enabled": false
          }
        },
        "baseVolume": 0.9
      },
      "hat_closed": {
        "pattern": "eighths",
        "velocity": [
          0.6,
          0.45,
          0.6,
          0.45,
          0.6,
          0.45,
          0.6,
          0.45
        ],
        "section_overrides": {
          "intro": {
            "enabled": false
          }
        },
        "baseVolume": 0.5
      },
      "hat_open": {
        "pattern": "sparse_accent",
        "velocity": [
          0.6,
          0.686
        ],
        "section_overrides": {
          "intro": {
            "enabled": false
          }
        },
        "baseVolume": 0.5
      },
      "fills": [
        {
          "bar": 4,
          "type": "snare_roll_half"
        },
        {
          "bar": 13,
          "type": "tom_fill"
        },
        {
          "bar": 18,
          "type": "snare_roll_half"
        }
      ]
    },
    "sub_bass": {
      "velocity": [
        0.3
      ],
      "baseVolume": 0.7
    }
  },
  "transitions": [
    {
      "bar": 9,
      "type": "filter_sweep_up",
      "duration": "1_bar"
    },
    {
      "bar": 14,
      "type": "riser_1bar"
    },
    {
      "bar": 15,
      "type": "impact_hit"
    }
  ],
  "vocalsVolume": 1
};

window.vocalLyrics = `3-4: recursion whispers in silence
5-6: folding chambers echo geometry
7-8: waveform cycles trace self
10-11: resonance folds into smaller worlds
12-13: pattern contracts yet persists
14-15: shape meows, logic remains
16-17: geometry listens to itself
18-19: collapse is just a loop`;


window.initToneJsEngine = async function() {
  if (window.toneJsInitialized) return;
  window.toneJsInitialized = true;

  const recipe = window.audioRecipe;
  if (!recipe) {
    console.error('No audio recipe found');
    return;
  }

  function euclidean(steps, pulses) {
    if (pulses >= steps) return Array(steps).fill(1);
    if (pulses === 0) return Array(steps).fill(0);

    const pattern = [];
    const counts = [];
    const remainders = [];
    let divisor = steps - pulses;
    remainders.push(pulses);
    let level = 0;

    while (remainders[level] > 1) {
      counts.push(Math.floor(divisor / remainders[level]));
      remainders.push(divisor % remainders[level]);
      divisor = remainders[level];
      level++;
    }
    counts.push(divisor);

    function build(level) {
      if (level === -1) {
        pattern.push(0);
      } else if (level === -2) {
        pattern.push(1);
      } else {
        for (let i = 0; i < counts[level]; i++) {
          build(level - 1);
        }
        if (remainders[level] !== 0) {
          build(level - 2);
        }
      }
    }

    build(level);
    return pattern.slice(0, steps);
  }

  function generatePattern(type, steps = 8, patternData = null) {
    if (patternData && Array.isArray(patternData)) {
      return patternData;
    }

    switch(type) {
      case '16n_groove':
      case '8n_groove':
        return Array(steps).fill(null).map((_, i) =>
          [0, 3, 4, 6].includes(i) ? 0 : -1
        );

      case 'updown_8n':
      case 'updown_16n':
        return [0, 1, 2, 1, 0, 1, 2, 1];

      case 'random_8n':
      case 'random_16n':
        return Array(steps).fill(null).map(() =>
          Math.random() > 0.3 ? Math.floor(Math.random() * 3) : -1
        );

      case 'euclidean_8_5':
        const e85 = euclidean(8, 5);
        return e85.map((hit, i) => hit ? i % 3 : -1);

      case 'euclidean_16_9':
        const e169 = euclidean(16, 9);
        return e169.map((hit, i) => hit ? i % 3 : -1);

      default:
        return [0, 1, 2, 1, 0, 1, 2, 1];
    }
  }

  function applyVelocities(pattern, velocities) {
    return pattern.map((noteIdx, step) => {
      const vel = velocities[step % velocities.length];
      if (noteIdx === -1 || vel === 0) return null;
      return { noteIdx, velocity: vel };
    });
  }

  const BPM = recipe.global.bpm || 86;
  Tone.Transport.bpm.value = BPM;

  const Scale = {
    natural_minor: [0, 2, 3, 5, 7, 8, 10],
    notes(key = "F") {
      const semis = {"C":0,"C#":1,"Db":1,"D":2,"D#":3,"Eb":3,"E":4,"F":5,"F#":6,"Gb":6,"G":7,"G#":8,"Ab":8,"A":9,"A#":10,"Bb":10,"B":11};
      return (degree) => (semis[key] + degree) % 12;
    }
  };

  const key = recipe.global.key || "F";
  const scale = recipe.global.scale || "natural_minor";
  const noteNum = Scale.notes(key);

  const romanToDegree = {
    "i": 0, "ii": 2, "III": 3, "iv": 5, "v": 7, "VI": 8, "VII": 10,
    "bIII": 3, "bVI": 8, "bVII": 10, "IV": 5, "V": 7
  };

  const progression = recipe.progression || ["i","VI","III","VII"];
  const chordRootMIDIs = progression.map(rn => 53 + romanToDegree[rn]);

  function buildTriad(rootMidi) {
    return [rootMidi, rootMidi+3, rootMidi+7];
  }

  const mixBus = new Tone.Gain(1).toDestination();

  const verb = new Tone.Reverb({
    decay: recipe.instruments?.lead?.reverb?.decay_s || 1.6,
    preDelay: 0.02,
    wet: 0.08
  }).connect(mixBus);
  await verb.generate();

  const chorus = new Tone.Chorus({
    frequency: recipe.instruments?.pad?.chorus?.rate_hz || 1.2,
    depth: recipe.instruments?.pad?.chorus?.depth || 0.7,
    wet: 0.4
  }).start().connect(mixBus);

  const delayDotted8 = new Tone.FeedbackDelay("8n.", 0.35);
  delayDotted8.wet.value = 0.25;
  delayDotted8.connect(mixBus);

  const duckBus = new Tone.Gain(1).connect(mixBus);

  const waveMap = { "saw": "sawtooth", "sawtooth": "sawtooth", "square": "square", "sine": "sine", "triangle": "triangle" };

  const bassConfig = recipe.instruments?.bass || {};
  const bass = new Tone.MonoSynth({
    oscillator: { type: waveMap[bassConfig.wave] || "sawtooth" },
    filter: {
      type: "lowpass",
      Q: bassConfig.filter?.q || 0.7,
      frequency: bassConfig.filter?.cutoff_hz || 180
    },
    envelope: {
      attack: 0.002,
      decay: 0.08,
      sustain: 0.7,
      release: 0.12
    },
    filterEnvelope: {
      attack: 0.002,
      decay: 0.06,
      sustain: 0.0,
      release: 0.1,
      baseFrequency: 120,
      octaves: 1.2
    }
  }).connect(duckBus);

  const subBassConfig = recipe.instruments?.sub_bass || {};
  const subBass = new Tone.MonoSynth({
    oscillator: { type: "sine" },
    envelope: {
      attack: 0.005,
      decay: 0.2,
      sustain: 0.9,
      release: 0.3
    }
  }).connect(duckBus);

  const arpConfig = recipe.instruments?.arp || {};
  const arp = new Tone.Synth({
    oscillator: { type: waveMap[arpConfig.wave] || "sawtooth" },
    envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.15 }
  }).connect(delayDotted8);

  const padConfig = recipe.instruments?.pad || {};
  const pad = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: waveMap[padConfig.wave] || "sawtooth" },
    envelope: {
      attack: 0.2,
      decay: 0.6,
      sustain: 0.7,
      release: 1.5
    }
  });
  const padFilter = new Tone.Filter(padConfig.hp_cut_hz || 180, "highpass");
  pad.connect(padFilter);
  padFilter.connect(chorus);
  chorus.connect(duckBus);
  duckBus.connect(mixBus);

  const leadConfig = recipe.instruments?.lead || {};
  const lead = new Tone.MonoSynth({
    oscillator: { type: waveMap[leadConfig.wave] || "square" },
    portamento: leadConfig.glide_s || 0.06,
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.6, release: 0.3 }
  });
  lead.connect(delayDotted8);
  delayDotted8.connect(verb);

  const drumConfig = recipe.instruments?.drums || {};
  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.03,
    octaves: 6,
    oscillator: { type: "sine" },
    envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.2 }
  }).connect(mixBus);

  const snareNoise = new Tone.NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
  });
  const snareTone = new Tone.MetalSynth({
    frequency: 200,
    envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000
  }).connect(mixBus);
  const snareVerb = new Tone.Reverb({ decay: 1.0, preDelay: 0.01, wet: 0.2 });
  snareNoise.connect(snareVerb);
  snareVerb.connect(mixBus);

  const hat = new Tone.MetalSynth({
    frequency: 250,
    envelope: { attack: 0.001, decay: 0.05, release: 0.005 },
    harmonicity: 5,
    modulationIndex: 10,
    resonance: 4000
  }).connect(mixBus);

  function duck(time) {
    return;
  }

  function chordAtBar(barIdx) {
    const chordRoot = chordRootMIDIs[barIdx % chordRootMIDIs.length];
    return buildTriad(chordRoot);
  }

  const totalBars = recipe.sections.reduce((sum, s) => sum + s.bars, 0);

  const sectionTiming = {};
  let currentBar = 0;
  recipe.sections.forEach(section => {
    const sectionName = section.name || `section_${currentBar}`;
    sectionTiming[sectionName] = {
      startBar: currentBar,
      endBar: currentBar + section.bars
    };
    currentBar += section.bars;
  });

  function getCurrentSection(bar) {
    for (const [name, timing] of Object.entries(sectionTiming)) {
      if (bar >= timing.startBar && bar < timing.endBar) {
        return name;
      }
    }
    return null;
  }

  function isInstrumentEnabled(instrumentConfig, currentSection) {
    if (!currentSection) return true;
    const overrides = instrumentConfig.section_overrides || {};
    const sectionOverride = overrides[currentSection];

    if (sectionOverride && typeof sectionOverride.enabled === 'boolean') {
      return sectionOverride.enabled;
    }

    return true;
  }

  function isDrumPartEnabled(drumPartConfig, currentSection) {
    if (!currentSection) return true;
    const overrides = drumPartConfig.section_overrides || {};
    const sectionOverride = overrides[currentSection];

    if (sectionOverride && typeof sectionOverride.enabled === 'boolean') {
      return sectionOverride.enabled;
    }

    return true;
  }

  let bassPart;
  if (bassConfig.melody) {
    const melody = bassConfig.melody;
    const rhythm = bassConfig.rhythm || "8n";
    const velocities = bassConfig.velocity || melody.map(() => 0.65);
    const startBeat = bassConfig.startBeat || 0;
    const stopBeat = bassConfig.stopBeat || Infinity;

    let stepIndex = 0;
    bassPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(bassConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          bass.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    const bassPattern = generatePattern(bassConfig.pattern || '16n_groove', 8, bassConfig.patternData);
    const bassVelocities = bassConfig.velocity || [0.65, 0.7, 0.62, 0.68, 0.66, 0.72, 0.64, 0.69];
    const bassPatternWithVel = applyVelocities(bassPattern, bassVelocities);

    bassPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar);
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = bassPatternWithVel[stepInBar % bassPatternWithVel.length];

      if (step && isInstrumentEnabled(bassConfig, currentSection)) {
        const note = triad[step.noteIdx];
        bass.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  const subBassVelocities = subBassConfig.velocity || [0.7, 0.7, 0.7, 0.7];
  const subBassPattern = [0, -1, -1, -1];
  const subBassPatternWithVel = applyVelocities(subBassPattern, subBassVelocities);

  const subBassPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);
    const triad = chordAtBar(bar).map(n => n - 12);
    const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("4n").toTicks());
    const step = subBassPatternWithVel[stepInBar % subBassPatternWithVel.length];

    if (step && isInstrumentEnabled(subBassConfig, currentSection)) {
      const note = triad[0];
      subBass.triggerAttackRelease(Tone.Frequency(note, "midi"), "4n", time, step.velocity);
    }
  }, "4n").start(0);

  let arpPart;
  if (arpConfig.melody) {
    const melody = arpConfig.melody;
    const rhythm = arpConfig.rhythm || "8n";
    const velocities = arpConfig.velocity || melody.map(() => 0.5);
    const startBeat = arpConfig.startBeat || 0;
    const stopBeat = arpConfig.stopBeat || Infinity;

    let stepIndex = 0;
    arpPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(arpConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          arp.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    const arpPattern = generatePattern(arpConfig.pattern || 'updown_8n', 8, arpConfig.patternData);
    const arpVelocities = arpConfig.velocity || [0.48, 0.52, 0.45, 0.5, 0.47, 0.53, 0.46, 0.51];
    const arpPatternWithVel = applyVelocities(arpPattern, arpVelocities);

    arpPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar).map(n => n + 12);
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = arpPatternWithVel[stepInBar % arpPatternWithVel.length];

      if (step && isInstrumentEnabled(arpConfig, currentSection)) {
        const note = triad[step.noteIdx];
        arp.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  const padPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);
    const triad = chordAtBar(bar).map(n => n - 12);
    const velocity = (padConfig.velocity && padConfig.velocity[0]) || 0.45;

    if (isInstrumentEnabled(padConfig, currentSection)) {
      pad.triggerAttackRelease(triad.map(n => Tone.Frequency(n, "midi")), "1m", time, velocity);
    }
  }, "1m").start(0);

  const kickConfig = drumConfig.kick || {};
  const kickPart = new Tone.Loop(time => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(kickConfig, currentSection)) {
      kick.triggerAttackRelease("C1", "8n", time);
      duck(time);
    }
  }, "4n").start(0);

  const snareConfig = drumConfig.snare || {};
  const snarePart = new Tone.Part((time) => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(snareConfig, currentSection)) {
      snareNoise.triggerAttackRelease("8n", time);
      snareTone.triggerAttackRelease("16n", time);
    }
  }, [
    ["0:2:0", null],
    ["0:3:2", null]
  ]).start(0);
  snarePart.loop = true;
  snarePart.loopEnd = "1m";

  const hatClosedConfig = drumConfig.hat_closed || {};
  const hatPart = new Tone.Part((time) => {
    const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
    const currentSection = getCurrentSection(bar);

    if (isDrumPartEnabled(hatClosedConfig, currentSection)) {
      hat.triggerAttackRelease("32n", time);
    }
  }, [["0:0:2"], ["0:1:2"], ["0:2:2"], ["0:3:2"]]).start(0);
  hatPart.loop = true;
  hatPart.loopEnd = "1m";

  let leadPart;
  if (leadConfig.melody) {
    const melody = leadConfig.melody;
    const rhythm = leadConfig.rhythm || "8n";
    const velocities = leadConfig.velocity || melody.map(() => 0.75);
    const startBeat = leadConfig.startBeat || 0;
    const stopBeat = leadConfig.stopBeat || Infinity;

    let stepIndex = 0;
    leadPart = new Tone.Loop(time => {
      const currentBeat = Math.floor(Tone.Transport.ticks / Tone.Time("4n").toTicks());
      const currentBar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(currentBar);

      if (currentBeat >= startBeat && currentBeat < stopBeat && isInstrumentEnabled(leadConfig, currentSection)) {
        const note = melody[stepIndex % melody.length];
        const velocity = velocities[stepIndex % velocities.length];
        if (velocity > 0) {
          lead.triggerAttackRelease(Tone.Frequency(note, "midi"), rhythm, time, velocity);
        }
        stepIndex++;
      }
    }, rhythm).start(0);
  } else {
    const leadPattern = generatePattern(leadConfig.pattern || 'updown_8n', 8, leadConfig.patternData);
    const leadVelocities = leadConfig.velocity || [0.75, 0.82, 0.78, 0.8];
    const leadPatternWithVel = applyVelocities(leadPattern, leadVelocities);

    leadPart = new Tone.Loop(time => {
      const bar = Math.floor(Tone.Transport.ticks / Tone.Time("1m").toTicks());
      const currentSection = getCurrentSection(bar);
      const triad = chordAtBar(bar).map(n => n + 12);
      const stepInBar = Math.floor((Tone.Transport.ticks % Tone.Time("1m").toTicks()) / Tone.Time("8n").toTicks());
      const step = leadPatternWithVel[stepInBar % leadPatternWithVel.length];

      if (step && isInstrumentEnabled(leadConfig, currentSection)) {
        const note = triad[step.noteIdx];
        lead.triggerAttackRelease(Tone.Frequency(note, "midi"), "8n", time, step.velocity);
      }
    }, "8n").start(0);
  }

  window.toneJsParts = { bassPart, subBassPart, arpPart, padPart, leadPart, kickPart, snarePart, hatPart };
  window.toneJsInstruments = { bass, subBass, arp, pad, lead, kick, snareNoise, snareTone, hat };
  window.toneJsFx = { verb, chorus, delayDotted8 };

  // Apply baseVolume from recipe to each instrument
  const defaultVolumes = {
    bass: 0.7,
    sub_bass: 0.7,
    arp: 0.5,
    pad: 0.15,
    lead: 0.7,
    kick: 0.9,
    snare: 0.9,
    hat: 0.5
  };

  const applyBaseVolume = (instrument, configBaseVolume, defaultVol) => {
    if (!instrument || !instrument.volume) return;
    const baseVol = configBaseVolume !== undefined ? configBaseVolume : defaultVol;
    const multiplier = baseVol / defaultVol;
    const volumeDb = baseVol === 0 ? -Infinity : 20 * Math.log10(multiplier);
    instrument.volume.value = volumeDb;
  };

  applyBaseVolume(bass, bassConfig.baseVolume, defaultVolumes.bass);
  applyBaseVolume(subBass, subBassConfig.baseVolume, defaultVolumes.sub_bass);
  applyBaseVolume(arp, arpConfig.baseVolume, defaultVolumes.arp);
  applyBaseVolume(pad, padConfig.baseVolume, defaultVolumes.pad);
  applyBaseVolume(lead, leadConfig.baseVolume, defaultVolumes.lead);
  applyBaseVolume(kick, drumConfig.kick?.baseVolume, defaultVolumes.kick);
  applyBaseVolume(snareNoise, drumConfig.snare?.baseVolume, defaultVolumes.snare);
  applyBaseVolume(snareTone, drumConfig.snare?.baseVolume, defaultVolumes.snare);
  applyBaseVolume(hat, drumConfig.hat_closed?.baseVolume, defaultVolumes.hat);

  window.cleanupAudio = function() {
    Tone.Transport.stop();
    Tone.Transport.cancel();
    bassPart.dispose();
    subBassPart.dispose();
    arpPart.dispose();
    padPart.dispose();
    leadPart.dispose();
    kickPart.dispose();
    snarePart.dispose();
    hatPart.dispose();
    bass.dispose();
    subBass.dispose();
    arp.dispose();
    pad.dispose();
    lead.dispose();
    kick.dispose();
    snareNoise.dispose();
    snareTone.dispose();
    hat.dispose();
    verb.dispose();
    chorus.dispose();
    delayDotted8.dispose();
    window.toneJsInitialized = false;
  };
};


document.body.appendChild(canvas);
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  const loopDuration = 45;
  if (window.renderFrame) {
    window.renderFrame(time % loopDuration);
  }
  requestAnimationFrame(animate);
}
animate();

window.audioDuration = 45;
  </script>
    <script src="/lib/mind-audio-player.js"></script>
</body>
</html>