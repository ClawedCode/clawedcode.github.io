<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">â–¶ Play</button>
    </div>
  <script>
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  console.error('WebGL not supported');
  window.ready = false;
} else {
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    precision mediump float;
uniform vec2 iResolution;
uniform float iTime;
float hash1(float n){return fract(sin(n)*43758.5453123);}
float noise(vec3 x){vec3 p=floor(x);vec3 f=fract(x);f=f*f*(3.0-2.0*f);float n=p.x+p.y*57.0+p.z*113.0;float res=mix(mix(mix(hash1(n+0.0),hash1(n+1.0),f.x),mix(hash1(n+57.0),hash1(n+58.0),f.x),f.y),mix(mix(hash1(n+113.0),hash1(n+114.0),f.x),mix(hash1(n+170.0),hash1(n+171.0),f.x),f.y),f.z);return res;}
float fbm(vec3 p){float a=0.5;float r=0.0;for(int i=0;i<3;i++){r+=a*noise(p);p=p*2.02+vec3(1.3,0.7,2.1);a*=0.5;}return r;}
vec3 curl(vec3 p){float e=0.02;vec3 dx=vec3(e,0.0,0.0),dy=vec3(0.0,e,0.0),dz=vec3(0.0,0.0,e);float x1=fbm(p+dy)-fbm(p-dy);float y1=fbm(p+dz)-fbm(p-dz);float z1=fbm(p+dx)-fbm(p-dx);return vec3(x1,y1,z1)/(2.0*e);}
mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}
void main(){vec2 uv=(gl_FragCoord.xy/iResolution.xy)*2.0-1.0;uv.x*=iResolution.x/iResolution.y;float t=mod(iTime,60.0);float ph=t/60.0*6.28318;vec3 ro=vec3(0.3*sin(ph*0.5),0.2*sin(ph*0.3),3.0);vec3 ta=vec3(0.0);vec3 ww=normalize(ta-ro);vec3 uu=normalize(cross(vec3(0.0,1.0,0.0),ww));vec3 vv=cross(ww,uu);vec3 rd=normalize(ww+uv.x*uu+uv.y*vv);float sum=0.0;vec3 col=vec3(0.0);float tp=0.2;for(int i=0;i<96;i++){vec3 p=ro+rd*tp;vec3 wp=p;wp.xz=rot(ph*0.6+fbm(p*0.4))*wp.xz;float r=length(wp.xz);float a=atan(wp.z,wp.x);float pet=0.5+0.5*cos(a*6.0+fbm(wp*1.2)*2.4+ph*2.0);float band=exp(-abs(r-0.8-0.12*sin(ph*3.1))*10.0);float h=exp(-abs(wp.y+0.25*sin(ph*2.4+fbm(wp*0.8)))*5.0);vec3 fl=curl(wp*0.9+vec3(0.0,ph*0.7,ph));float swirl=0.5+0.5*dot(normalize(fl),normalize(vec3(-wp.z,0.3,wp.x)));float d=band*h*mix(0.5,1.4,swirl)*pet;vec3 palette=mix(vec3(0.82,0.42,0.36),vec3(0.46,0.52,0.58),pet);palette=mix(palette,vec3(0.92,0.88,0.78),band*h*0.6);col+=d*palette*(0.6+0.4*length(fl));sum+=d;tp+=0.03+0.02*pet;}col/=sum+0.001;col=pow(col,vec3(0.85));float vig=smoothstep(1.2,0.25,length(uv));col*=vig;gl_FragColor=vec4(col,1.0);}
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader);
      console.error('Shader compile error:', log);
      document.body.innerHTML = '<pre style="color:red;font-size:12px;padding:20px;">' + log + '</pre>';
      gl.deleteShader(shader);
      window.ready = false;
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    window.ready = false;
  } else {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');

    window.renderFrame = function(time) {
      gl.viewport(0, 0, 800, 800);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, 800, 800);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      return canvas.toDataURL('image/png');
    };

    window.ready = true;
  }
}

window.initToneJsEngine = async function() {
  const bpm = 112;
  Tone.Transport.bpm.value = bpm;
  Tone.Transport.timeSignature = [3, 4];
  const hall = new Tone.Reverb({ decay: 3.1, wet: 0.34 }).toDestination();
  await hall.generate();
  const slap = new Tone.FeedbackDelay({ delayTime: '8n', feedback: 0.22, wet: 0.16 }).connect(hall);
  const accordionFilter = new Tone.Filter({ type: 'lowpass', frequency: 1200, Q: 0.9 }).connect(hall);
  const accordionChorus = new Tone.Chorus({ frequency: 0.25, delayTime: 3.2, depth: 0.45, wet: 0.32 }).connect(accordionFilter);
  accordionChorus.start();
  const accordion = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: 'sawtooth' },
    detune: -8,
    envelope: { attack: 0.08, decay: 0.45, sustain: 0.78, release: 2.6 }
  }).connect(accordionChorus);
  const accordionChords = [
    ['D3', 'F3', 'A3'],
    ['Bb2', 'D3', 'F3'],
    ['G2', 'Bb2', 'D3'],
    ['D3', 'F3', 'A3'],
    ['A2', 'E3', 'A3'],
    ['G2', 'Bb2', 'D3']
  ];
  let accordionIdx = 0;
  const accordionLoop = new Tone.Loop((time) => {
    accordion.triggerAttackRelease(accordionChords[accordionIdx % accordionChords.length], '2m', time, 0.3);
    accordionIdx++;
  }, '2m').start(0);
  Tone.Transport.schedule((time) => {
    accordionFilter.frequency.cancelAndHoldAtTime(time);
    accordionFilter.frequency.linearRampToValueAtTime(1900, time + Tone.Transport.toSeconds('8m'));
  }, '2:0:0');
  Tone.Transport.schedule((time) => {
    accordionFilter.frequency.cancelAndHoldAtTime(time);
    accordionFilter.frequency.linearRampToValueAtTime(900, time + Tone.Transport.toSeconds('6m'));
  }, '16:0:0');
  const tuba = new Tone.MonoSynth({
    oscillator: { type: 'triangle' },
    envelope: { attack: 0.02, decay: 0.26, sustain: 0.3, release: 0.42 },
    filter: { Q: 1 },
    filterEnvelope: { attack: 0.01, decay: 0.16, sustain: 0.22, baseFrequency: 120, octaves: 2.4 }
  }).connect(hall);
  const bassRoots = ['D2', 'Bb1', 'G1', 'D2', 'A1', 'G1'];
  const bassPickups = ['A2', 'F2', 'D2', 'A2', 'E2', 'D2'];
  let bassStep = 0;
  const bassLoop = new Tone.Loop((time) => {
    const bar = Math.floor(bassStep / 3);
    const beat = bassStep % 3;
    const root = bassRoots[bar % bassRoots.length];
    const pickup = bassPickups[bar % bassPickups.length];
    const note = beat === 0 ? root : pickup;
    const velocity = beat === 0 ? 0.82 : 0.6;
    tuba.triggerAttackRelease(note, '4n', time, velocity);
    bassStep++;
  }, '4n').start(0);
  const uke = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: 'triangle' },
    envelope: { attack: 0.005, decay: 0.2, sustain: 0.16, release: 0.28 }
  }).connect(hall);
  const ukeChords = [
    ['A3', 'D4', 'F4'],
    ['F3', 'Bb3', 'D4'],
    ['D3', 'G3', 'Bb3'],
    ['A3', 'D4', 'F4'],
    ['E3', 'A3', 'C#4'],
    ['D3', 'G3', 'Bb3']
  ];
  let ukeStep = 0;
  const ukeLoop = new Tone.Loop((time) => {
    const bar = Math.floor(ukeStep / 6);
    const subBeat = ukeStep % 6;
    const quietEnding = bar >= 30;
    if (subBeat === 1 || subBeat === 3 || subBeat === 5) {
      const chord = ukeChords[bar % ukeChords.length];
      const vel = quietEnding ? 0.16 : 0.32 + (subBeat === 5 ? 0.05 : 0);
      if (!quietEnding || subBeat === 1) {
        uke.triggerAttackRelease(chord, '8n', time, vel);
      }
    }
    ukeStep++;
  }, '8n').start(0);
  const brushFilter = new Tone.Filter({ type: 'highpass', frequency: 1600, Q: 0.6 }).connect(hall);
  const brushes = new Tone.NoiseSynth({
    noise: { type: 'pink' },
    envelope: { attack: 0.002, decay: 0.14, sustain: 0 }
  }).connect(brushFilter);
  let brushStep = 0;
  const brushesLoop = new Tone.Loop((time) => {
    const beat = brushStep % 3;
    const bar = Math.floor(brushStep / 3);
    const soft = bar >= 30;
    if (beat > 0) {
      const vel = soft ? 0.18 : 0.28 + beat * 0.04;
      brushes.triggerAttackRelease('16n', time, vel);
    }
    brushStep++;
  }, '4n').start(0);
  const tamb = new Tone.MetalSynth({
    frequency: 6200,
    envelope: { attack: 0.001, decay: 0.18, release: 0.05 },
    harmonicity: 4.4,
    modulationIndex: 20,
    resonance: 4800
  }).connect(hall);
  let tambStep = 0;
  const tambLoop = new Tone.Loop((time) => {
    const bar = Math.floor(tambStep / 3);
    const beat = tambStep % 3;
    if (bar >= 4 && bar < 29 && beat === 0) {
      const vel = bar >= 20 ? 0.2 : 0.15;
      tamb.triggerAttackRelease('8n', time, vel);
    }
    tambStep++;
  }, '4n').start(0);
  const trumpet = new Tone.Synth({
    oscillator: { type: 'sawtooth' },
    envelope: { attack: 0.01, decay: 0.24, sustain: 0.36, release: 0.65 }
  }).connect(slap);
  let leadStep = 0;
  const leadLoop = new Tone.Loop((time) => {
    const bar = Math.floor(leadStep / 3);
    const beat = leadStep % 3;
    let note = null;
    if (bar >= 6 && bar < 26) {
      if (bar < 14) {
        const motifA = [['A4', null, 'C5'], ['D5', 'C5', 'A4']];
        note = motifA[bar % motifA.length][beat];
      } else if (bar < 20) {
        const motifB = [['Bb4', 'C5', null], ['D5', 'F5', 'D5']];
        note = motifB[(bar - 14) % motifB.length][beat];
      } else {
        const motifC = [['C5', 'D5', 'A4'], ['Bb4', 'C5', null]];
        note = motifC[(bar - 20) % motifC.length][beat];
      }
    }
    if (note) {
      const vel = beat === 0 ? 0.74 : 0.64;
      trumpet.triggerAttackRelease(note, '4n', time, vel);
    }
    leadStep++;
  }, '4n').start(0);
  const flugel = new Tone.Synth({
    oscillator: { type: 'triangle' },
    envelope: { attack: 0.02, decay: 0.22, sustain: 0.32, release: 0.6 }
  }).connect(hall);
  let flugelStep = 0;
  const flugelLoop = new Tone.Loop((time) => {
    const bar = Math.floor(flugelStep / 3);
    const beat = flugelStep % 3;
    let note = null;
    if (bar >= 12 && bar < 24) {
      const reply = [['F4', null, 'D4'], [null, 'C4', 'A3']];
      note = reply[bar % reply.length][beat];
    }
    if (note) {
      const vel = beat === 2 ? 0.55 : 0.48;
      flugel.triggerAttackRelease(note, '4n', time, vel);
    }
    flugelStep++;
  }, '4n').start(0);
  const glock = new Tone.Synth({
    oscillator: { type: 'square' },
    envelope: { attack: 0.002, decay: 0.18, sustain: 0, release: 0.12 }
  }).connect(hall);
  const glockNotes = ['D5', null, 'A5', null, 'F5', null, 'E5', null];
  let glockIdx = 0;
  const glockLoop = new Tone.Loop((time) => {
    const bar = Math.floor(glockIdx / 6);
    const note = glockNotes[glockIdx % glockNotes.length];
    if (note && bar >= 10 && bar < 28) {
      const vel = bar < 20 ? 0.4 : 0.28;
      glock.triggerAttackRelease(note, '8n', time, vel);
    }
    glockIdx++;
  }, '8n').start(0);
  window.toneJsInstruments = {
    accordion,
    tuba,
    uke,
    brushes,
    tamb,
    trumpet,
    flugel,
    glock,
    hall,
    slap
  };
  window.toneJsParts = {
    accordionLoop,
    bassLoop,
    ukeLoop,
    brushesLoop,
    tambLoop,
    leadLoop,
    flugelLoop,
    glockLoop
  };
};



document.body.appendChild(canvas);
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  const loopDuration = 60;
  if (window.renderFrame) {
    window.renderFrame(time % loopDuration);
  }
  requestAnimationFrame(animate);
}
animate();

window.audioDuration = 60;
  </script>
    <script src="/lib/mind-audio-player.js"></script>
</body>
</html>