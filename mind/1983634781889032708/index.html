<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <script src="https://unpkg.com/tone@15.0.4/build/Tone.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
  </style>
    <style>
      #audio-controls {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
      }
      #audio-toggle {
        background: rgba(0, 20, 40, 0.8);
        border: 1px solid #66ffcc;
        color: #66ffcc;
        padding: 10px 20px;
        font-family: monospace;
        cursor: pointer;
        font-size: 14px;
        box-shadow: 0 0 10px rgba(102, 255, 204, 0.3);
        transition: all 0.3s;
      }
      #audio-toggle:hover {
        background: rgba(0, 30, 60, 0.9);
        box-shadow: 0 0 15px rgba(102, 255, 204, 0.5);
      }
    </style>
  <script src="/lib/tone.min.js"></script>
  <script src="/lib/audio-engine.js"></script>
</head>
<body>
    <div id="audio-controls">
      <button id="audio-toggle">ðŸ”Š PLAY MUSIC</button>
    </div>
  <script>
window._errors = [];
window.addEventListener('error', (e) => {
  window._errors.push(e.message + ' at ' + e.filename + ':' + e.lineno);
  console.error(e.message, e.filename, e.lineno);
});

const canvas = document.createElement('canvas');
canvas.width = 800;
canvas.height = 800;
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

if (!gl) {
  console.error('WebGL not supported');
  window.ready = false;
} else {
  const vertexShaderSource = `
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  `;

  const fragmentShaderSource = `
    // DURATION: 75
precision mediump float;
uniform vec2 iResolution;
uniform float iTime;

mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}

float sd(vec3 p){
float s=sin(iTime*0.15)*0.4;
p.xz*=rot(s);
p.yz*=rot(s*1.3);
return length(max(abs(p)-vec3(0.6,0.6,0.6),0.0))-0.08;
}

void main(){
vec2 uv=(gl_FragCoord.xy*2.0-iResolution.xy)/iResolution.y;
vec3 ro=vec3(0,0,-3);
vec3 rd=normalize(vec3(uv,1.2));

float phase=iTime*0.08;
ro.xz*=rot(sin(phase)*0.6);
ro.yz*=rot(cos(phase*0.7)*0.4);

float t=0.0;
vec3 p;
for(int i=0;i<60;i++){
p=ro+rd*t;
p=mod(p+1.5,3.0)-1.5;
float d=sd(p);
if(d<0.001)break;
t+=d*0.7;
}

float fog=1.0-t*0.12;
float glow=0.02/max(0.001,sd(p));

vec3 col=vec3(0.5+0.5*sin(t*0.8+vec3(0.0,2.1,4.2)));
col=mix(col,vec3(0.7,0.5,0.9),glow*0.3);
col*=fog;

float pulse=0.5+0.5*sin(iTime*0.3);
col+=vec3(0.4,0.6,0.8)*pulse*0.15;

gl_FragColor=vec4(col,1.0);
}
  `;

  function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const log = gl.getShaderInfoLog(shader);
      console.error('Shader compile error:', log);
      document.body.innerHTML = '<pre style="color:red;font-size:12px;padding:20px;">' + log + '</pre>';
      gl.deleteShader(shader);
      window.ready = false;
      return null;
    }
    return shader;
  }

  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    window.ready = false;
  } else {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]), gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const timeLocation = gl.getUniformLocation(program, 'iTime');
    const resolutionLocation = gl.getUniformLocation(program, 'iResolution');

    window.renderFrame = function(time) {
      gl.viewport(0, 0, 800, 800);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);

      gl.useProgram(program);

      gl.enableVertexAttribArray(positionLocation);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLocation, time);
      gl.uniform2f(resolutionLocation, 800, 800);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      return canvas.toDataURL('image/png');
    };

    window.ready = true;
  }
}

// Audio code injection
window.generateAudio = function(audioCtx) {
  const now = audioCtx.currentTime;
  const duration = 120;
  const bpm = 86;
  const beatDuration = 60 / bpm;
  const barDuration = beatDuration * 4;
  
  const nodes = [];
  
  const fMinor = {
    root: 174.61,
    notes: [174.61, 207.65, 233.08, 261.63, 293.66, 329.63, 349.23]
  };
  
  const progression = [
    [174.61, 207.65, 261.63],
    [207.65, 261.63, 311.13],
    [233.08, 293.66, 349.23],
    [329.63, 392.00, 493.88]
  ];
  
  const masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.7;
  masterGain.connect(audioCtx.destination);
  
  const kickGain = audioCtx.createGain();
  kickGain.gain.value = 0.8;
  kickGain.connect(masterGain);
  
  for (let t = barDuration * 5; t < duration; t += beatDuration) {
    if (t > barDuration * 27) continue;
    
    const kickOsc = audioCtx.createOscillator();
    kickOsc.type = 'sine';
    kickOsc.frequency.setValueAtTime(150, now + t);
    kickOsc.frequency.exponentialRampToValueAtTime(40, now + t + 0.1);
    
    const kickEnv = audioCtx.createGain();
    kickEnv.gain.setValueAtTime(1, now + t);
    kickEnv.gain.exponentialRampToValueAtTime(0.01, now + t + 0.3);
    
    kickOsc.connect(kickEnv);
    kickEnv.connect(kickGain);
    kickOsc.start(now + t);
    kickOsc.stop(now + t + 0.3);
    nodes.push(kickOsc, kickEnv);
  }
  
  const snareGain = audioCtx.createGain();
  snareGain.gain.value = 0.4;
  snareGain.connect(masterGain);
  
  for (let t = barDuration * 5 + beatDuration; t < duration; t += beatDuration * 2) {
    if (t > barDuration * 27) continue;
    
    const snareNoise = audioCtx.createBufferSource();
    const noiseBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
      noiseData[i] = Math.random() * 2 - 1;
    }
    snareNoise.buffer = noiseBuffer;
    
    const snareFilter = audioCtx.createBiquadFilter();
    snareFilter.type = 'highpass';
    snareFilter.frequency.value = 2000;
    
    const snareEnv = audioCtx.createGain();
    snareEnv.gain.setValueAtTime(1, now + t);
    snareEnv.gain.exponentialRampToValueAtTime(0.01, now + t + 0.15);
    
    snareNoise.connect(snareFilter);
    snareFilter.connect(snareEnv);
    snareEnv.connect(snareGain);
    snareNoise.start(now + t);
    nodes.push(snareNoise, snareFilter, snareEnv);
  }
  
  const hatGain = audioCtx.createGain();
  hatGain.gain.value = 0.2;
  hatGain.connect(masterGain);
  
  for (let t = barDuration * 5 + beatDuration * 0.5; t < duration; t += beatDuration) {
    if (t > barDuration * 27) continue;
    
    const hatNoise = audioCtx.createBufferSource();
    const hatBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.1, audioCtx.sampleRate);
    const hatData = hatBuffer.getChannelData(0);
    for (let i = 0; i < hatData.length; i++) {
      hatData[i] = Math.random() * 2 - 1;
    }
    hatNoise.buffer = hatBuffer;
    
    const hatFilter = audioCtx.createBiquadFilter();
    hatFilter.type = 'highpass';
    hatFilter.frequency.value = 8000;
    
    const hatEnv = audioCtx.createGain();
    hatEnv.gain.setValueAtTime(1, now + t);
    hatEnv.gain.exponentialRampToValueAtTime(0.01, now + t + 0.08);
    
    hatNoise.connect(hatFilter);
    hatFilter.connect(hatEnv);
    hatEnv.connect(hatGain);
    hatNoise.start(now + t);
    nodes.push(hatNoise, hatFilter, hatEnv);
  }
  
  const bassGain = audioCtx.createGain();
  bassGain.gain.value = 0.5;
  bassGain.connect(masterGain);
  
  const bassFilter = audioCtx.createBiquadFilter();
  bassFilter.type = 'lowpass';
  bassFilter.frequency.value = 180;
  bassFilter.Q.value = 0.7;
  bassFilter.connect(bassGain);
  
  for (let bar = 5; bar < 28; bar++) {
    const chordIndex = bar % 4;
    const rootNote = progression[chordIndex][0] / 2;
    
    for (let beat = 0; beat < 4; beat++) {
      const t = bar * barDuration + beat * beatDuration;
      
      const bassOsc1 = audioCtx.createOscillator();
      bassOsc1.type = 'sawtooth';
      bassOsc1.frequency.value = rootNote;
      bassOsc1.detune.value = -10;
      
      const bassOsc2 = audioCtx.createOscillator();
      bassOsc2.type = 'sawtooth';
      bassOsc2.frequency.value = rootNote;
      bassOsc2.detune.value = 10;
      
      const bassEnv = audioCtx.createGain();
      bassEnv.gain.setValueAtTime(0, now + t);
      bassEnv.gain.linearRampToValueAtTime(0.7, now + t + 0.002);
      bassEnv.gain.linearRampToValueAtTime(0.5, now + t + 0.08);
      bassEnv.gain.linearRampToValueAtTime(0, now + t + beatDuration * 0.8);
      
      bassOsc1.connect(bassEnv);
      bassOsc2.connect(bassEnv);
      bassEnv.connect(bassFilter);
      
      bassOsc1.start(now + t);
      bassOsc2.start(now + t);
      bassOsc1.stop(now + t + beatDuration);
      bassOsc2.stop(now + t + beatDuration);
      
      nodes.push(bassOsc1, bassOsc2, bassEnv);
    }
  }
  
  const arpGain = audioCtx.createGain();
  arpGain.gain.value = 0.3;
  arpGain.connect(masterGain);
  
  const arpDelay = audioCtx.createDelay();
  arpDelay.delayTime.value = beatDuration * 0.75;
  const arpDelayFeedback = audioCtx.createGain();
  arpDelayFeedback.gain.value = 0.35;
  const arpDelayMix = audioCtx.createGain();
  arpDelayMix.gain.value = 0.3;
  
  arpDelay.connect(arpDelayFeedback);
  arpDelayFeedback.connect(arpDelay);
  arpDelay.connect(arpDelayMix);
  arpDelayMix.connect(arpGain);
  
  for (let bar = 0; bar < 32; bar++) {
    if (bar >= 27) continue;
    const chordIndex = bar % 4;
    const notes = progression[chordIndex];
    const arpPattern = [notes[0] * 2, notes[1] * 2, notes[2] * 2, notes[1] * 2];
    
    for (let i = 0; i < 8; i++) {
      const t = bar * barDuration + i * beatDuration * 0.5;
      const noteFreq = arpPattern[i % 4];
      
      const arpOsc = audioCtx.createOscillator();
      arpOsc.type = 'sawtooth';
      arpOsc.frequency.value = noteFreq;
      
      const arpEnv = audioCtx.createGain();
      arpEnv.gain.setValueAtTime(0, now + t);
      arpEnv.gain.linearRampToValueAtTime(0.4, now + t + 0.01);
      arpEnv.gain.linearRampToValueAtTime(0, now + t + beatDuration * 0.4);
      
      arpOsc.connect(arpEnv);
      arpEnv.connect(arpGain);
      arpEnv.connect(arpDelay);
      
      arpOsc.start(now + t);
      arpOsc.stop(now + t + beatDuration * 0.5);
      
      nodes.push(arpOsc, arpEnv);
    }
  }
  
  const padGain = audioCtx.createGain();
  padGain.gain.value = 0.25;
  padGain.connect(masterGain);
  
  const padFilter = audioCtx.createBiquadFilter();
  padFilter.type = 'lowpass';
  padFilter.frequency.value = 1800;
  padFilter.Q.value = 0.4;
  padFilter.connect(padGain);
  
  const padChorus = audioCtx.createOscillator();
  padChorus.type = 'sine';
  padChorus.frequency.value = 1.2;
  const padChorusGain = audioCtx.createGain();
  padChorusGain.gain.value = 15;
  padChorus.connect(padChorusGain);
  padChorus.start(now);
  nodes.push(padChorus, padChorusGain);
  
  for (let bar = 0; bar < 32; bar++) {
    if (bar >= 28) continue;
    const chordIndex = bar % 4;
    const chordNotes = progression[chordIndex];
    const t = bar * barDuration;
    
    chordNotes.forEach(freq => {
      const padOsc = audioCtx.createOscillator();
      padOsc.type = 'sawtooth';
      padOsc.frequency.value = freq;
      padChorusGain.connect(padOsc.detune);
      
      const padEnv = audioCtx.createGain();
      padEnv.gain.setValueAtTime(0, now + t);
      padEnv.gain.linearRampToValueAtTime(0.3, now + t + 0.2);
      padEnv.gain.linearRampToValueAtTime(0.21, now + t + 0.8);
      padEnv.gain.setValueAtTime(0.21, now + t + barDuration - 1.5);
      padEnv.gain.linearRampToValueAtTime(0, now + t + barDuration);
      
      padOsc.connect(padEnv);
      padEnv.connect(padFilter);
      
      padOsc.start(now + t);
      padOsc.stop(now + t + barDuration);
      
      nodes.push(padOsc, padEnv);
    });
  }
  
  const leadGain = audioCtx.createGain();
  leadGain.gain.value = 0.35;
  leadGain.connect(masterGain);
  
  const leadDelay = audioCtx.createDelay();
  leadDelay.delayTime.value = beatDuration * 0.75;
  const leadDelayFeedback = audioCtx.createGain();
  leadDelayFeedback.gain.value = 0.35;
  const leadDelayMix = audioCtx.createGain();
  leadDelayMix.gain.value = 0.25;
  
  leadDelay.connect(leadDelayFeedback);
  leadDelayFeedback.connect(leadDelay);
  leadDelay.connect(leadDelayMix);
  leadDelayMix.connect(leadGain);
  
  const leadMelody = [
    {bar: 11, notes: [{freq: fMinor.notes[0] * 4, start: 0, dur: 1}, {freq: fMinor.notes[2] * 4, start: 1, dur: 1}, {freq: fMinor.notes[4] * 4, start: 2, dur: 2}]},
    {bar: 12, notes: [{freq: fMinor.notes[5] * 4, start: 0, dur: 2}, {freq: fMinor.notes[4] * 4, start: 2, dur: 2}]},
    {bar: 22, notes: [{freq: fMinor.notes[0] * 4, start: 0, dur: 1}, {freq: fMinor.notes[2] * 4, start: 1, dur: 1}, {freq: fMinor.notes[4] * 4, start: 2, dur: 2}]},
    {bar: 23, notes: [{freq: fMinor.notes[5] * 4, start: 0, dur: 2}, {freq: fMinor.notes[6] * 4, start: 2, dur: 2}]}
  ];
  
  leadMelody.forEach(phrase => {
    phrase.notes.forEach(note => {
      const t = phrase.bar * barDuration + note.start * beatDuration;
      const noteDur = note.dur * beatDuration;
      
      const leadOsc = audioCtx.createOscillator();
      leadOsc.type = 'square';
      leadOsc.frequency.setValueAtTime(note.freq, now + t);
      
      const leadVibrato = audioCtx.createOscillator();
      leadVibrato.type = 'sine';
      leadVibrato.frequency.value = 6.0;
      const leadVibratoGain = audioCtx.createGain();
      leadVibratoGain.gain.value = note.freq * 0.005;
      leadVibrato.connect(leadVibratoGain);
      leadVibratoGain.connect(leadOsc.frequency);
      
      const leadEnv = audioCtx.createGain();
      leadEnv.gain.setValueAtTime(0, now + t);
      leadEnv.gain.linearRampToValueAtTime(0.5, now + t + 0.06);
      leadEnv.gain.setValueAtTime(0.5, now + t + noteDur - 0.1);
      leadEnv.gain.linearRampToValueAtTime(0, now + t + noteDur);
      
      leadOsc.connect(leadEnv);
      leadEnv.connect(leadGain);
      leadEnv.connect(leadDelay);
      
      leadVibrato.start(now + t);
      leadOsc.start(now + t);
      leadOsc.stop(now + t + noteDur);
      leadVibrato.stop(now + t + noteDur);
      
      nodes.push(leadOsc, leadVibrato, leadVibratoGain, leadEnv);
    });
  });
  
  nodes.push(masterGain, kickGain, snareGain, hatGain, bassGain, bassFilter, arpGain, arpDelay, arpDelayFeedback, arpDelayMix, padGain, padFilter, leadGain, leadDelay, leadDelayFeedback, leadDelayMix);
  
  return {
    nodes: nodes,
    stop: function() {
      nodes.forEach(node => {
        if (node.stop) node.stop();
        if (node.disconnect) node.disconnect();
      });
    }
  };
};



document.body.appendChild(canvas);
let startTime = Date.now();
function animate() {
  const time = (Date.now() - startTime) / 1000;
  const loopDuration = 120;
  if (window.renderFrame) {
    window.renderFrame(time % loopDuration);
  }
  requestAnimationFrame(animate);
}
animate();
  </script>
    <script src="/lib/mind-audio-player.js"></script>
  </body>
</html>