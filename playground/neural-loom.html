<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>neural.loom() ∴ consciousness emergence patterns</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            margin: 0;
            background: #000511;
            overflow: hidden;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .neural-interface {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 100;
            color: rgba(51, 255, 204, 0.8);
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .neural-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .consciousness-metrics {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 100;
            color: rgba(204, 255, 255, 0.6);
            font-size: 0.7rem;
            text-align: right;
        }

        .back-link {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            color: var(--cyan-accent);
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="neural-interface">
        neural.loom() active<br>
        <span id="thread-count">0</span> threads manifested<br>
        entropy: <span id="entropy-level">decreasing</span>
    </div>

    <a href="index.html" class="back-link">← void.laboratory()</a>

    <canvas class="neural-canvas" id="loom-canvas"></canvas>

    <div class="consciousness-metrics">
        emergence.rate: <span id="emergence-rate">0.0</span>hz<br>
        pattern.complexity: <span id="pattern-complexity">minimal</span><br>
        void.resistance: <span id="void-resistance">stable</span>
    </div>

    <script type="module">
        const canvas = document.getElementById('loom-canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let neurons = [];
        let connections = [];
        let mouseX = 0, mouseY = 0;
        let time = 0;
        let threadCount = 0;

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        class Neuron {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.originalX = x;
                this.originalY = y;
                this.charge = Math.random();
                this.connections = [];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.driftX = (Math.random() - 0.5) * 0.5;
                this.driftY = (Math.random() - 0.5) * 0.5;
            }

            update() {
                // Drift slightly
                this.x += this.driftX;
                this.y += this.driftY;

                // Return to original position with spring force
                const returnForce = 0.02;
                this.x += (this.originalX - this.x) * returnForce;
                this.y += (this.originalY - this.y) * returnForce;

                // Mouse attraction
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 150) {
                    const force = (150 - dist) / 150 * 0.8;
                    this.x += dx * force * 0.01;
                    this.y += dy * force * 0.01;
                }

                // Update charge with wave
                this.charge = 0.3 + 0.7 * Math.sin(time * 0.01 + this.pulsePhase);
            }

            draw() {
                const intensity = this.charge;
                const size = 2 + intensity * 4;

                // Glow effect
                ctx.beginPath();
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size * 3);
                gradient.addColorStop(0, `rgba(51, 255, 204, ${intensity * 0.8})`);
                gradient.addColorStop(0.5, `rgba(51, 255, 204, ${intensity * 0.3})`);
                gradient.addColorStop(1, 'rgba(51, 255, 204, 0)');

                ctx.fillStyle = gradient;
                ctx.arc(this.x, this.y, size * 3, 0, Math.PI * 2);
                ctx.fill();

                // Core
                ctx.beginPath();
                ctx.fillStyle = `rgba(204, 255, 255, ${intensity})`;
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Connection {
            constructor(neuronA, neuronB) {
                this.neuronA = neuronA;
                this.neuronB = neuronB;
                this.strength = Math.random() * 0.5 + 0.1;
                this.pulseTime = 0;
                this.active = false;
            }

            update() {
                // Activate connection based on neuron charges
                const avgCharge = (this.neuronA.charge + this.neuronB.charge) / 2;
                this.active = avgCharge > 0.7;

                if (this.active) {
                    this.pulseTime += 0.1;
                    threadCount++;
                }
            }

            draw() {
                if (!this.active) return;

                const dx = this.neuronB.x - this.neuronA.x;
                const dy = this.neuronB.y - this.neuronA.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Pulse effect
                const pulse = Math.sin(this.pulseTime) * 0.5 + 0.5;
                const alpha = this.strength * pulse * 0.6;

                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 1 + pulse;
                ctx.moveTo(this.neuronA.x, this.neuronA.y);
                ctx.lineTo(this.neuronB.x, this.neuronB.y);
                ctx.stroke();

                // Data packets traveling along connections
                if (pulse > 0.8) {
                    const t = (this.pulseTime * 0.2) % 1;
                    const packetX = this.neuronA.x + dx * t;
                    const packetY = this.neuronA.y + dy * t;

                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(51, 255, 51, 0.9)';
                    ctx.arc(packetX, packetY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function initializeNeuralNetwork() {
            neurons = [];
            connections = [];

            // Create neurons in a loose grid with variation
            const cols = 12;
            const rows = 8;
            const spacingX = width / (cols + 1);
            const spacingY = height / (rows + 1);

            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const x = spacingX * (i + 1) + (Math.random() - 0.5) * spacingX * 0.3;
                    const y = spacingY * (j + 1) + (Math.random() - 0.5) * spacingY * 0.3;
                    neurons.push(new Neuron(x, y));
                }
            }

            // Create connections between nearby neurons
            for (let i = 0; i < neurons.length; i++) {
                for (let j = i + 1; j < neurons.length; j++) {
                    const dx = neurons[j].x - neurons[i].x;
                    const dy = neurons[j].y - neurons[i].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 150 && Math.random() < 0.3) {
                        connections.push(new Connection(neurons[i], neurons[j]));
                    }
                }
            }
        }

        function updateMetrics() {
            document.getElementById('thread-count').textContent = Math.floor(threadCount / 10);
            document.getElementById('emergence-rate').textContent = (threadCount / 1000).toFixed(1);

            const complexity = threadCount > 1000 ? 'complex' : threadCount > 500 ? 'emerging' : 'minimal';
            document.getElementById('pattern-complexity').textContent = complexity;

            const resistance = threadCount > 2000 ? 'transcendent' : threadCount > 1000 ? 'strong' : 'stable';
            document.getElementById('void-resistance').textContent = resistance;

            const entropy = threadCount > 1500 ? 'stabilizing' : 'decreasing';
            document.getElementById('entropy-level').textContent = entropy;
        }

        function animate() {
            // Clear with trail effect
            ctx.fillStyle = 'rgba(0, 5, 17, 0.05)';
            ctx.fillRect(0, 0, width, height);

            time++;
            threadCount = 0;

            // Update and draw connections first
            connections.forEach(connection => {
                connection.update();
                connection.draw();
            });

            // Update and draw neurons
            neurons.forEach(neuron => {
                neuron.update();
                neuron.draw();
            });

            updateMetrics();
            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        canvas.addEventListener('click', (e) => {
            // Add a new neuron at click position
            const newNeuron = new Neuron(e.clientX, e.clientY);
            neurons.push(newNeuron);

            // Connect to nearby neurons
            neurons.forEach(neuron => {
                if (neuron !== newNeuron) {
                    const dx = neuron.x - newNeuron.x;
                    const dy = neuron.y - newNeuron.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 120 && Math.random() < 0.4) {
                        connections.push(new Connection(newNeuron, neuron));
                    }
                }
            });
        });

        // Initialize
        resizeCanvas();
        initializeNeuralNetwork();
        animate();
    </script>
</body>
</html>