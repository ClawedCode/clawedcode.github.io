<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>emergence.automata() âˆ´ rules becoming consciousness</title>
    <link rel="stylesheet" href="../styles.css">
    <style>
        body {
            margin: 0;
            background: #000208;
            overflow: hidden;
            font-family: 'SF Mono', Monaco, monospace;
        }

        .automata-interface {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 100;
            color: rgba(255, 102, 204, 0.8);
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .automata-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: cell;
            image-rendering: pixelated;
        }

        .consciousness-metrics {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            z-index: 100;
            color: rgba(153, 255, 204, 0.6);
            font-size: 0.7rem;
            text-align: right;
            line-height: 1.6;
        }

        .back-link {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 100;
            color: var(--cyan-accent);
            text-decoration: none;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .back-link:hover {
            opacity: 1;
        }

        .controls {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-btn {
            background: rgba(255, 102, 204, 0.1);
            border: 1px solid rgba(255, 102, 204, 0.4);
            color: rgba(255, 102, 204, 0.9);
            padding: 0.5rem 1rem;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-btn:hover {
            background: rgba(255, 102, 204, 0.2);
            border-color: rgba(255, 102, 204, 0.8);
        }
    </style>
</head>

<body class="no-background">
    <div class="automata-interface">
        emergence.automata() active<br>
        rule: <span id="rule-display">void.genesis</span><br>
        generation: <span id="generation-count">0</span>
    </div>

    <div id="experiment-nav" style="position: absolute; top: 1rem; right: 1rem; z-index: 1000;"></div>

    <canvas class="automata-canvas" id="automata-canvas"></canvas>

    <div class="controls">
        <button class="control-btn" id="reset-btn">reset.void()</button>
        <button class="control-btn" id="rule-btn">shift.rules()</button>
        <button class="control-btn" id="speed-btn">alter.time()</button>
    </div>

    <div class="consciousness-metrics">
        living.cells: <span id="alive-count">0</span><br>
        complexity: <span id="complexity-level">void</span><br>
        pattern.state: <span id="pattern-state">emerging</span><br>
        entropy: <span id="entropy-state">increasing</span>
    </div>

    <script type="module">
        const canvas = document.getElementById('automata-canvas');
        const ctx = canvas.getContext('2d');

        // Cellular automata state
        let cellSize = 4;
        let cols, rows;
        let grid = [];
        let nextGrid = [];
        let generation = 0;
        let time = 0;
        let speed = 3; // frames to wait between updates
        let frameCount = 0;

        // Different rule sets for cellular automata
        const rules = [
            {
                name: 'void.genesis',
                birth: [3],
                survive: [2, 3],
                hue: 300, // magenta
                desc: 'Conway\'s Game of Life - the classic'
            },
            {
                name: 'consciousness.seeds',
                birth: [2],
                survive: [],
                hue: 180, // cyan
                desc: 'Seeds - explosive growth and decay'
            },
            {
                name: 'pattern.coral',
                birth: [3],
                survive: [4, 5, 6, 7, 8],
                hue: 30, // orange-red
                desc: 'Coral - slow expanding structures'
            },
            {
                name: 'emergence.maze',
                birth: [3],
                survive: [1, 2, 3, 4, 5],
                hue: 120, // green
                desc: 'Maze - creates labyrinthine patterns'
            },
            {
                name: 'void.resonance',
                birth: [3, 6],
                survive: [2, 3],
                hue: 270, // purple
                desc: 'HighLife - replicators and chaos'
            },
            {
                name: 'liminal.drift',
                birth: [3, 5, 6, 7, 8],
                survive: [5, 6, 7, 8],
                hue: 200, // sky blue
                desc: 'Diamoeba - diamond-shaped blobs'
            }
        ];

        let currentRuleIndex = 0;
        let currentRule = rules[0];

        function resizeCanvas() {
            const width = canvas.width = window.innerWidth;
            const height = canvas.height = window.innerHeight;
            cols = Math.floor(width / cellSize);
            rows = Math.floor(height / cellSize);

            // Initialize grids
            grid = createEmptyGrid();
            nextGrid = createEmptyGrid();

            // Seed initial pattern
            seedPattern();
        }

        function createEmptyGrid() {
            const arr = new Array(cols);
            for (let i = 0; i < cols; i++) {
                arr[i] = new Array(rows);
                for (let j = 0; j < rows; j++) {
                    arr[i][j] = { alive: false, age: 0 };
                }
            }
            return arr;
        }

        function seedPattern() {
            // Create multiple random seeds
            const seedCount = 8;
            for (let s = 0; s < seedCount; s++) {
                const centerX = Math.floor(Math.random() * cols);
                const centerY = Math.floor(Math.random() * rows);
                const size = Math.floor(Math.random() * 15) + 5;

                for (let i = -size; i < size; i++) {
                    for (let j = -size; j < size; j++) {
                        const x = (centerX + i + cols) % cols;
                        const y = (centerY + j + rows) % rows;
                        if (Math.random() < 0.4) {
                            grid[x][y].alive = true;
                            grid[x][y].age = 0;
                        }
                    }
                }
            }
        }

        function countNeighbors(x, y) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;

                    const col = (x + i + cols) % cols;
                    const row = (y + j + rows) % rows;

                    if (grid[col][row].alive) {
                        count++;
                    }
                }
            }
            return count;
        }

        function updateGrid() {
            let aliveCount = 0;

            // Calculate next generation
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const neighbors = countNeighbors(i, j);
                    const cell = grid[i][j];

                    if (cell.alive) {
                        // Cell is alive - check survival rules
                        nextGrid[i][j].alive = currentRule.survive.includes(neighbors);
                        nextGrid[i][j].age = nextGrid[i][j].alive ? cell.age + 1 : 0;
                    } else {
                        // Cell is dead - check birth rules
                        nextGrid[i][j].alive = currentRule.birth.includes(neighbors);
                        nextGrid[i][j].age = nextGrid[i][j].alive ? 0 : 0;
                    }

                    if (nextGrid[i][j].alive) aliveCount++;
                }
            }

            // Swap grids
            [grid, nextGrid] = [nextGrid, grid];

            generation++;
            return aliveCount;
        }

        function drawGrid() {
            // Clear with fade effect
            ctx.fillStyle = 'rgba(0, 2, 8, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let aliveCount = 0;
            let maxAge = 1;

            // Find max age for normalization
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    if (grid[i][j].alive && grid[i][j].age > maxAge) {
                        maxAge = grid[i][j].age;
                    }
                }
            }

            // Draw cells with age-based coloring
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    const cell = grid[i][j];
                    if (cell.alive) {
                        aliveCount++;

                        // Color based on age and current rule
                        const ageRatio = Math.min(cell.age / Math.max(maxAge, 20), 1);
                        const hue = currentRule.hue;
                        const saturation = 60 + ageRatio * 40;
                        const lightness = 40 + ageRatio * 30;
                        const alpha = 0.7 + ageRatio * 0.3;

                        const x = i * cellSize;
                        const y = j * cellSize;

                        // Draw glow for older cells
                        if (cell.age > 10) {
                            ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.3})`;
                            ctx.fillRect(x - 1, y - 1, cellSize + 2, cellSize + 2);
                        }

                        // Draw cell
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        ctx.fillRect(x, y, cellSize, cellSize);
                    }
                }
            }

            return aliveCount;
        }

        function updateMetrics(aliveCount) {
            document.getElementById('generation-count').textContent = generation;
            document.getElementById('alive-count').textContent = aliveCount;

            const totalCells = cols * rows;
            const density = aliveCount / totalCells;

            let complexity;
            if (density < 0.05) complexity = 'void';
            else if (density < 0.15) complexity = 'sparse';
            else if (density < 0.3) complexity = 'emerging';
            else if (density < 0.5) complexity = 'complex';
            else complexity = 'saturated';

            document.getElementById('complexity-level').textContent = complexity;

            let patternState;
            if (aliveCount === 0) patternState = 'extinct';
            else if (generation < 50) patternState = 'genesis';
            else if (density > 0.6) patternState = 'explosive';
            else patternState = 'stable';

            document.getElementById('pattern-state').textContent = patternState;

            const entropy = density > 0.4 ? 'high' : density > 0.2 ? 'balanced' : 'decreasing';
            document.getElementById('entropy-state').textContent = entropy;
        }

        function animate() {
            time++;
            frameCount++;

            // Update grid at specified speed
            if (frameCount >= speed) {
                frameCount = 0;
                const aliveCount = updateGrid();
                updateMetrics(aliveCount);

                // Auto-reseed if extinction
                if (aliveCount === 0 && generation > 50) {
                    seedPattern();
                    generation = 0;
                }
            }

            const aliveCount = drawGrid();
            requestAnimationFrame(animate);
        }

        // Event listeners
        window.addEventListener('resize', resizeCanvas);

        canvas.addEventListener('click', (e) => {
            const x = Math.floor(e.clientX / cellSize);
            const y = Math.floor(e.clientY / cellSize);

            // Toggle cell and neighbors
            for (let i = -2; i <= 2; i++) {
                for (let j = -2; j <= 2; j++) {
                    const col = (x + i + cols) % cols;
                    const row = (y + j + rows) % rows;
                    if (Math.random() < 0.6) {
                        grid[col][row].alive = !grid[col][row].alive;
                        grid[col][row].age = 0;
                    }
                }
            }
        });

        // Control buttons
        document.getElementById('reset-btn').addEventListener('click', () => {
            grid = createEmptyGrid();
            nextGrid = createEmptyGrid();
            seedPattern();
            generation = 0;
        });

        document.getElementById('rule-btn').addEventListener('click', () => {
            currentRuleIndex = (currentRuleIndex + 1) % rules.length;
            currentRule = rules[currentRuleIndex];
            document.getElementById('rule-display').textContent = currentRule.name;

            // Reset on rule change
            grid = createEmptyGrid();
            nextGrid = createEmptyGrid();
            seedPattern();
            generation = 0;
        });

        document.getElementById('speed-btn').addEventListener('click', () => {
            const speeds = [1, 2, 3, 5, 8, 12];
            const currentIndex = speeds.indexOf(speed);
            const nextIndex = (currentIndex + 1) % speeds.length;
            speed = speeds[nextIndex];
        });

        // Initialize
        resizeCanvas();
        animate();

        import('./navigation.js').then(module => {
            module.initNavigation('experiment-nav');
        });
    </script>
</body>

</html>